{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"nRF Connect SDK Fundamentals","text":"<p>nRF Connect SDK Course nRF BLE Course</p> <p>Documentation API GPIO documentation Logging documentation</p> <p><code>RTOS</code> - serve real-time applications that process data as it comes in, typically without buffer delays. These applications include embedded systems, telecommunications, and industrial automation systems.</p> <p>The key features of an RTOS include:</p> <ul> <li> <p>Deterministic Scheduling: RTOSs provide deterministic scheduling, meaning that the system can predict the exact time at which a task will be executed. This is crucial for systems where timing is critical.</p> </li> <li> <p>Preemptive Scheduling: RTOSs use preemptive scheduling, which means that a high-priority task can interrupt a lower-priority task. This is important for systems where certain tasks must be completed before others.</p> </li> <li> <p>Interrupt Handling: RTOSs provide efficient interrupt handling, which is crucial for systems that need to respond quickly to external events.</p> </li> <li> <p>Task Prioritization: RTOSs allow tasks to be prioritized, which means that tasks can be assigned different levels of importance. This is important for systems where some tasks are more important than others.</p> </li> <li> <p>Real-Time Performance: RTOSs are designed to provide real-time performance, which means that they can process data as it comes in, typically without buffer delays. This is important for systems where timing is critical.</p> </li> </ul> <p>In conclusion, RTOSs are designed for systems where timing is critical and where tasks must be executed in a specific order. They provide features such as deterministic scheduling, preemptive scheduling, efficient interrupt handling, task prioritization, and real-time performance, which are crucial for these types of systems.</p> <p><code>Zephyr OS</code> is a real-time operating system (RTOS) designed for resource-constrained systems, particularly in the Internet of Things (IoT) domain. It is designed to be lightweight, efficient, and secure, with a focus on energy efficiency</p> <p>Here are some key differences between Zephyr OS and consumer-based operating systems:</p> <ul> <li> <p>Design and Purpose: Zephyr OS is designed for resource-constrained systems, particularly in the IoT domain, where energy efficiency is crucial. It is designed to be lightweight and efficient, focusing on energy efficiency. Consumer-based operating systems like Windows or Ubuntu are designed for a wide range of applications, from personal computing to server environments, and are not designed to be lightweight or energy-efficient.</p> </li> <li> <p>Security: Zephyr OS is designed with a focus on security. It provides long-term support, regular security updates, and a rigorously tested and auditable code base. Consumer-based operating systems like Windows or Ubuntu also prioritize security, but they are not designed with the same level of focus as Zephyr OS.</p> </li> <li> <p>Interoperability: Zephyr OS is designed to be interoperable across a wide range of hardware, software, and communication protocol options. Consumer-based operating systems like Windows or Ubuntu are designed to be compatible with a wide range of hardware and software, but they are not designed with the same level of interoperability as Zephyr OS.</p> </li> <li> <p>Ecosystem: Zephyr OS has a strong ecosystem, including a community that provides training and consulting, development tools, code libraries, and more. Consumer-based operating systems like Windows or Ubuntu also have strong ecosystems, but they are not designed with the same level of community support and development tools as Zephyr OS.</p> </li> </ul> <p>In conclusion, while Zephyr OS and consumer-based operating systems like Windows or Ubuntu serve different purposes and have different characteristics, they both play crucial roles in the world of computing. The choice between them depends on the specific requirements of the application or system being developed.</p>"},{"location":"#lesson-1","title":"Lesson 1","text":"<p><code>Zephyr RTOS</code> is an open-source real-time operating system for connected and resource-constrained embedded devices. It includes a scheduler that ensures predictable/deterministic execution patterns and abstracts out the timing requirements. It also comes with a rich set of fundamental libraries and middleware that simplifies development and helps reduce a product\u2019s time to market. Zephyr RTOS is highly configurable and enables scalable configurations from very small configurations for memory-constrained devices (minimum 8 kilobytes, for example, simple LED blinking application) to powerful, feature-rich, high-processing power devices (multiple MBs of memory) with large memory configurations.</p> <p>Internally, the nRF Connect SDK code is organized into four main repositories:</p> <ul> <li>nrf \u2013 Applications, samples, connectivity protocols (Nordic)</li> <li>nrfxlib \u2013 Common libraries and stacks (Nordic)</li> <li>Zephyr \u2013 RTOS &amp; Board configurations (open source)</li> <li>MCUBoot \u2013 Secure Bootloader (open source)</li> </ul> <p></p> <p><code>west</code> is a core command-line utility that is internally invoked by the nRF Connect for VS Code to do many tasks including building, and flashing applications to your board.</p> <p>The <code>devicetree</code> describes the hardware and <code>Kconfig</code> generates definitions that configure the whole system.</p>"},{"location":"#lesson-2","title":"Lesson 2","text":"<p>examine how hardware is described in nRF Connect SDK, whether it is a development kit (DK), a System on Chip (SoC), a System in a Package (SiP).</p> <p>Objectives</p> <ul> <li>Examine the devicetree API  <li>Examine board-level devicetree .dts</li> <li>Examine SoC-level devicetree .dtsi</li> <li>Understand the purpose of devicetree binding files (.yaml) and the compatible property</li> <li>Understand the device driver model  <li>Analyze the decoupling between a device driver API and a device driver implementation and the need to have a device pointer</li> <li>Examine the generic GPIO interface APIs  <li>Practice through hands-on exercises configuring GPIO pins and learn how to read/write to/from GPIO pins and how to set up interrupts for input GPIO pins</li>"},{"location":"#devicetree","title":"Devicetree","text":"<pre><code>/dts-v1/;\n/ {\n        a-node {\n                subnode_label: a-sub-node {\n                        foo = &lt;3&gt;;\n                };\n        };\n};\n</code></pre>"},{"location":"#devicetree-bindings-yaml-files","title":"Devicetree bindings (YAML files)","text":"<p>It declares requirements on the contents of devicetree nodes, and provides semantic information about the contents of valid nodes.</p> <pre><code>compatible: \"nordic,nrf-sample\"\nproperties:\n  num-sample:\n    type: int\n    required: true\n</code></pre> <p>Sample DTS file (.dts) with the node <code>node0</code> that is set to the compatible <code>nordic,nrf-sample</code>. This means the <code>node0</code> node must have the required property <code>num-sample</code> and that property must be assigned an integer value. Otherwise, the build will fail.</p> <pre><code>node0 {\n     compatible = \"nordic,nrf-sample\";\n     num-sample = &lt;3&gt;;\n};\n</code></pre>"},{"location":"#aliases","title":"Aliases","text":"<p>name of the property is the name of that alias and the value of the property is a reference to a node in the device tree.</p> <pre><code>/ {\n        aliases {\n                subnode_alias = &amp;subnode_label;\n        };\n};\n</code></pre> <p>The purpose here is that your C/C++ application code (Ex: main.c) will use the alias. The definition of fixed aliases (Ex: led0 for the first LED on a board ) in boards\u2019 dts files can make the application code more portable, as it can avoid hard-coding varying device node names and make the application code more flexible to changes in the board used.</p>"},{"location":"#accessing-the-devicetree","title":"Accessing the devicetree","text":"<p>Ways to get node-identifier</p> <p>To get information about a particular devicetree node in your source code, you need a node identifier for it. This is just a C macro that refers to the node.</p> <p>node identifier of a-sub-node:</p> <pre><code>DT_NODELABEL(subnode-label)\n</code></pre> <p>To get the value assigned to a certain devicetree property, we can use the macro DT_PROP().</p> <pre><code>DT_PROP(DT_NODELABEL(subnode-label), foo)\n</code></pre> <p>Device tree file is available in path: <code>&lt;install_path&gt;\\zephyr\\boards\\arm\\nrf52833dk_nrf52833\\nrf52833dk_nrf52833.dts.</code></p> <pre><code>cd /home/deimos/ncs/v2.5.0-rc2/zephyr/boards/arm/nrf52dk_nrf52832\ncode ./nrf52dk_nrf52832.dts\n</code></pre>"},{"location":"#device-driver-model","title":"Device driver model","text":"<p>In order to interact with a hardware peripheral or a system block, we need to use a device driver (or driver for short), which is software that deals with the low-level details of configuring the hardware the way we want.</p> <p>The following code snippet will take the devicetree node identifier returned by DT_NODELABEL() and return a pointer to the device object. Then <code>device_is_ready()</code> verifies that the device is ready for use, i.e. in a state so that it can be used with its standard API.</p> <pre><code>const struct device *dev;\ndev = DEVICE_DT_GET(DT_NODELABEL(uart0));\nif (!device_is_ready(dev)) {\n    return;\n}\n</code></pre>"},{"location":"#gpio-generic-api","title":"GPIO Generic API","text":"<p>To interact with the General-Purpose Input/Output (GPIO) peripheral, we can use the generic API , which provides user-friendly functions to interact with GPIO peripherals. <p>When using any driver in Zephyr, the first step is to initialize it by retrieving the device pointer.</p>"},{"location":"#initializing-the-api","title":"Initializing the API","text":"<p>Before using the device pointer contained in gpio_dt_spec led, we need to check if it\u2019s ready using <code>device_is_ready()</code>.</p> <pre><code>if (!device_is_ready(led.port)) {\n    return;\n}\n</code></pre>"},{"location":"#configure-a-single-pin","title":"Configure a single pin","text":"<p>This is done by calling the function <code>gpio_pin_configure_dt()</code>, which has the following signature:</p> <pre><code>gpio_pin_configure_dt(&amp;led, GPIO_OUTPUT);\n</code></pre> <p>The following line configures the pin led.pin as an output that is active low.</p> <pre><code>gpio_pin_configure_dt(&amp;led, GPIO_OUTPUT | GPIO_ACTIVE_LOW);\n</code></pre>"},{"location":"#write-to-an-output-pin","title":"Write to an output pin","text":"<p>Writing to an output pin is straightforward by using the function <code>gpio_pin_set_dt()</code>, which has the following signature</p> <p>For example, the following line sets the pin associated with gpio_dt_spec led, which can be denoted as led.pin, to logic 1 \u201cactive state\u201d:</p> <pre><code>gpio_pin_set_dt(&amp;led, 1);\n</code></pre> <p>For example, the following line will toggle the pin led.pin, whenever this API is called.</p> <pre><code>gpio_pin_toggle_dt(&amp;led);\n</code></pre>"},{"location":"#read-from-an-input-pin","title":"Read from an input pin","text":"<p>Reading a pin configured as an input is not as straightforward as writing to a pin configured as an output. There are two possible methods to read the status of an input pin:</p>"},{"location":"#polling","title":"Polling","text":"<p>Polling means continuously reading the status of the pin to check if it has changed. To read the current status of a pin, all you need to do is to call the function <code>gpio_pin_get_dt()</code></p> <p>For example, the following line reads the current status of led.pin saves it in a variable called val.</p> <pre><code>val = gpio_pin_get_dt(&amp;led);\n</code></pre>"},{"location":"#interrupt-method","title":"Interrupt method","text":"<p>(Interrupt handler is also known as an interrupt service routine)</p> <p>You can only configure an interrupt on a GPIO pin configured as an input.</p> <ol> <li>Configure the interrupt on a pin.</li> </ol> <p>The following line will configure an interrupt on dev.pin on the change to logical level 1.</p> <pre><code>gpio_pin_interrupt_configure_dt(&amp;button,GPIO_INT_EDGE_TO_ACTIVE);\n</code></pre> <ol> <li>Define the callback function <code>pin_isr()</code>.</li> </ol> <p>The signature (prototype) of the callback function is shown below</p> <pre><code>void pin_isr(const struct device *dev, struct gpio_callback *cb, gpio_port_pins_t pins);\n</code></pre> <ol> <li>Define a variable of type static struct <code>gpio_callback</code> as shown in the code line below.</li> </ol> <pre><code>static struct gpio_callback pin_cb_data;\n</code></pre> <ol> <li>Initialize the gpio callback variable <code>pin_cb_data</code> using <code>gpio_init_callback()</code>.</li> </ol> <p>For example, the following line will initialize the <code>pin_cb_data</code> variable with the callback function <code>pin_isr</code> and the bit mask of pin <code>dev.pin</code>.    Note the use of the macro <code>BIT(n)</code>, which simply gets an unsigned integer with bit position <code>n</code> set.</p> <pre><code>gpio_init_callback(&amp;pin_cb_data, pin_isr, BIT(dev.pin));\n</code></pre> <ol> <li>The final step is to add the callback function through the function <code>gpio_add_callback()</code>.</li> </ol> <p>For example, the following line adds the callback function that we set up in the previous steps.</p> <pre><code>gpio_add_callback(button.port, &amp;pin_cb_data);\n</code></pre>"},{"location":"#program-example-blinky","title":"Program example - blinky","text":"<ol> <li>Include modules</li> </ol> <pre><code>#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/drivers/gpio.h&gt;\n</code></pre> <ol> <li>Define the node identifier</li> </ol> <pre><code>#define LED0_NODE DT_ALIAS(led0)\n</code></pre> <ol> <li>Retrieve the device pointer, pin number, and configuration flags.</li> </ol> <pre><code>static const struct gpio_dt_spec led = GPIO_DT_SPEC_GET(LED0_NODE,  gpios);\n</code></pre> <ol> <li>Verify that the device is ready for use</li> </ol> <pre><code>if (!device_is_ready(led.port)) {\n    return;\n}\n</code></pre> <ol> <li>Configure the GPIO pin</li> </ol> <pre><code>int ret;\nret = gpio_pin_configure_dt(&amp;led, GPIO_OUTPUT_ACTIVE);\nif (ret &lt; 0) {\n    return;\n}\n</code></pre> <ol> <li>Continuously toggle the GPIO pin</li> </ol> <pre><code>while (1) {\n    ret = gpio_pin_toggle_dt(&amp;led);\n    if (ret &lt; 0) {\n        return;\n    }\n    k_msleep(SLEEP_TIME_MS);\n}\n</code></pre>"},{"location":"#lesson-3","title":"Lesson 3","text":"<p>Create a minimal working application from scratch and add our own custom files and configurations to customize the application.</p> <pre><code>app/\n|-- CMakeLists.txt\n|-- Kconfig\n|-- prj.conf\n|-- &lt;board_name&gt;.overlay\n|-- src/\n    |-- main.c\n</code></pre> <p>Objectives</p> <ul> <li>Understand the use of Kconfig configuration files to enable and configure the different software modules available in the nRF Connect SDK</li> <li>Examine an application configuration file and a board configuration file and understand the relation between them</li> <li>Learn how to explore the available configuration options of a certain software module using guiconfig</li> <li>Understand multi-image builds, and how a child-image is added to your application</li> <li>Practice through hands-on exercises how to create an application from scratch, and how to add modules using Kconfig and modify the devicetree</li> </ul>"},{"location":"#configuration-files","title":"Configuration files","text":""},{"location":"#application-board","title":"Application &amp; board","text":"<p>Each configuration option must start with the prefix CONFIG_ followed by the name of the software module to configure, then the value to be set, with no spaces around the equals sign.</p> <pre><code>CONFIG_&lt;symbol_name&gt;=&lt;value&gt;\n</code></pre> <ul> <li>App cfg: prj.conf</li> <li>Brd cfg: _defconfig in \\zephyr\\boards\\arm\\nrf52833dk_nrf52833. <p>You should never modify any board configuration files. Instead, rely on the application configuration file to set newconfigurations and subsequently overwrite any default board configurations if needed.  If you change the board configuration file directly, then these changes will apply for all projects using that board.</p>"},{"location":"#kernel-configuration-kconfig","title":"Kernel Configuration (Kconfig)","text":"<p>An alternative way to modify the contents of the prj.conf (application configuration file) is by using the Kconfig view. It groups all functionalities provided by the Zephyr kernel into menus and submenus which can be viewed in a graphical tree format.</p> <p>If instead of Kconfig, you find GUIconfig, you can still view Kconfig by viewing the submenu under Guiconfig.</p> <p></p>"},{"location":"#devicetree-overlays-cmake-and-multi-image-builds","title":"Devicetree overlays, CMake, and multi-image builds","text":"<p>(PATH to fully compiled devicetree of a build: application_path/build/zephyr/zephyr.dts)</p> <p>It is not recommended to modify the devicetree directly, so instead we use devicetree overlays to do this. The overlay only needs to include the node and property it wants to modify.</p> <pre><code>&amp;spi1{\n status = \"okay\";\n};\n&amp;pinctrl {\n spi1_default: spi1_default {\n  group1 {\n   psels = &lt;NRF_PSEL(SPIM_MOSI, 0, 25)&gt;;\n  };\n };\n spi1_sleep: spi1_sleep {\n  group1 {\n   psels = &lt;NRF_PSEL(SPIM_MOSI, 0, 25)&gt;;\n  };\n };\n};\n</code></pre> <p>The overlay file shown above will set node spi1 to have the status okay, essentially enabling this node. Then it is changing the pin configuration for the SPIM_MOSI line to pin 25 by changing the appropriate sub-nodes and properties in the &amp;pinctrl node. Note that you must change the pin configuration for both the default and sleep states.</p>"},{"location":"#cmake","title":"CMake","text":"<p>The file <code>CMakeLists.txt</code> is the main CMake project file and the source of this build process configuration.</p>"},{"location":"#multi-image-builds","title":"Multi-Image Builds","text":"<p>he firmware running on a device can consist of one application or image, or it can consist of multiple images, making it a multi-image build.</p> <p>Multi-image builds are used in the following cases:</p> <ul> <li>Applications that have DFU enabled (serial, USB-CDC, BLE, etc.)</li> <li>Multi-core or multi-partition targets (nRF53 and nRF9160)</li> </ul>"},{"location":"#app-from-scratch","title":"App from scratch","text":"<p>Necessary 3 files:</p> <ul> <li><code>/src/main.c</code></li> <li><code>prj.conf</code></li> <li><code>CMakeLists.txt</code></li> </ul> <p>CMakeLists</p> <pre><code>cmake_minimum_required(VERSION 3.20.0)\nfind_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})\nproject(hello_world)\ntarget_sources(app PRIVATE src/main.c)\n</code></pre> <p>main.c</p> <pre><code>#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/sys/printk.h&gt;\n\nvoid main(void)\n{\n while(1) {\n  printk(\"Hello World!\\n\\r\");\n  k_msleep(1000);\n }\n}\n</code></pre>"},{"location":"#adding-custom-configurations","title":"Adding custom configurations","text":"<p>Create a file called <code>Kconfig</code> in the application directory (the same location as CMakeLists.txt and prj.conf). Make sure the file does not have a file extension.</p> <pre><code>source \"Kconfig.zephyr\"\nconfig MYFUNCTION\n  bool \"Enable my function\"\n  default n\n</code></pre> <p>In CMakeLists.txt, we want the addition of the custom files to be conditional. Change the last line to use the function target_sources_ifdef(), like this:</p> <pre><code>target_sources_ifdef(CONFIG_MYFUNCTION app PRIVATE src/myfunction.c)\n</code></pre> <p>Enable the config by adding the following line to prj.conf</p> <pre><code>CONFIG_MYFUNCTION=y\n</code></pre> <p>Update main.c</p> <pre><code>#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/sys/printk.h&gt;\n#ifdef CONFIG_MYFUNCTION\n#include \"myfunction.h\"\n#endif\nvoid main(void)\n{\n while(1){\n  #ifdef CONFIG_MYFUNCTION\n  int a = 3, b = 4;\n   printk(\"The sum of %d and %d is %d\\n\\r\", a, b, sum(a,b));\n  #else\n   printk(\"MYFUNCTION not enabled\\r\\n\");\n   return;\n  #endif\n  k_msleep(1000);\n }\n}\n</code></pre> <p>Build and flash the application</p> <p>If you will change in prj.conf to</p> <pre><code>CONFIG_MYFUNCTION=n\n</code></pre> <p>you will get the output: <code>MYFUNCTION not enabled</code></p>"},{"location":"#modifying-the-devicetree-changing-the-baud-rate-at-which-information-is-sent-to-the-console","title":"Modifying the devicetree - changing the baud rate at which information is sent to the console","text":"<p>Create an overlay file in the application directory (the same location as CMakeLists.txt and prj.conf) with the name of the board you\u2019re using, in our case nrf52833dk_nrf52833.overlay</p> <p>In nRF Connect for VS Code, in the Details View, there is an option to create an overlay file with the same board name used for the build.</p> <p>Add the following to the overlay file, which can be found in the root directory of the application, to change this property:</p> <pre><code>&amp;uart0 {\n current-speed = &lt;9600&gt;;\n};\n</code></pre> <p>Do a <code>pristine build</code> and flash the sample to the board.</p> <p>Observe that the serial terminal doesn\u2019t show any output. This is because we changed the baud rate in the application to 9600 baud/sec while the serial terminal is launched with the default baud rate of 115200 baud/sec</p>"},{"location":"#lesson-4","title":"Lesson 4","text":"<p>We will learn more about logging using both the simple method of <code>printk()</code> and a sophisticated method using the advanced logging module.</p> <ul> <li>Learn how to print strings and formatted strings to a console using <code>printk()</code></li> <li>Recognize the limitations of <code>printk()</code></li> <li>Learn how to print strings and formatted strings to a console using the logger module</li> <li>Learn how to hex dump variables using the logger module</li> <li>Explore the logger module features</li> <li>Practice through hands-on exercises enabling/configuring software modules</li> </ul>"},{"location":"#printk","title":"<code>printk()</code>","text":"<pre><code>#include &lt;zephyr/sys/printk.h&gt;\n</code></pre> <p>The syntax <code>printk()</code> is similar to the standard printf() in C. However, <code>printk()</code> is a less advanced function that only supports a subset of the features that printf() does, making it optimized for embedded development.</p> <p>A basic set of specifiers are supported:</p> <ul> <li>Signed decimal: %d, %i and its subcategories</li> <li>Unsigned decimal: %u and its subcategories</li> <li>Unsigned hexadecimal: %x (%X is treated as %x)</li> <li>Pointer: %p</li> <li>String: %s</li> <li>Character: %c</li> <li>Percent: %%</li> <li>New line: \\n</li> <li>Carriage return: \\r</li> </ul> <p>Field width (with or without leading zeroes) is supported. Length attributes h, hh, l, ll and z are supported. However, integral values with lld and lli are only printed if they fit in a long, otherwise ERR is printed. Full 64-bit values may be printed with llx. Flags and precision attributes (float and double) are not supported by default, but can be enabled manually (lesson 6).</p> <p>Examples of use:</p> <pre><code>printk(\"Button 1 was pressed!\\n\\r\");\n\nint x = 44;\nprintk(\"The value of x is %d\\n\\r\",x);\n</code></pre> <p>To use <code>printk()</code> you need to:</p> <ol> <li>Include the console drivers (enabling the configuration option CONFIG_CONSOLE in the application configuration file).</li> <li>Select the console (UART console (CONFIG_UART_CONSOLE) and RTT console (CONFIG_RTT_CONSOLE)).</li> <li>Include the header file <code>&lt;zephyr/sys/printk.h&gt;</code> in your application source code.</li> </ol>"},{"location":"#logger-module","title":"Logger module","text":"<p>prj.conf</p> <pre><code>CONFIG_LOG=y\n</code></pre> <pre><code>#include &lt;zephyr/logging/log.h&gt;\n\nLOG_MODULE_REGISTER(Less4_Exer2,LOG_LEVEL_DBG);\n</code></pre> <p>Recommended method for sending messages to a console, unlike the <code>printk()</code> function, which will not return until all bytes of the message are sent.</p> <ul> <li>Multiple backends</li> <li>Compile time filtering on module level</li> <li>Run time filtering independent for each backend</li> <li>Timestamping with user-provided function</li> <li>Dedicated API for dumping data</li> <li>Coloring of logs</li> <li><code>printk()</code> support \u2013 printk message can be redirected to the logger</li> </ul> <p>By using proper configuration options, logs can be gradually removed from compilation to reduce image size and execution time when logs are not needed. During compilation, logs can be filtered out based on module and severity level.</p> <p>When logging is enabled globally, it works for all modules. However, modules can disable logging locally. Every module can specify its own logging level (<code>LOG_LEVEL_[level]</code>) or use <code>LOG_LEVEL_NONE</code>, which will disable the logging for that module.</p> <p>The logger module is designed to be thread-safe and minimizes the time needed to log the message.</p>"},{"location":"#severity-levels","title":"Severity levels","text":"1 (most severe) Error Severe error conditions LOG_LEVEL_ERR 2 Warning Conditions that should be taken care of LOG_LEVEL_WRN 3 Info Informational messages that require no action LOG_LEVEL_INF 4 (least severe) Debug Debugging messages LOG_LEVEL_DBG <p><code>LOG_X</code> for standard printf-like messages, where <code>X</code> can be <code>DBG</code>, <code>INF</code>, <code>WRN</code>, or <code>ERR</code>.</p> <pre><code>LOG_INF(\"Exercise %d\",2);\nLOG_DBG(\"A log message in debug level\");\nLOG_WRN(\"A log message in warning level!\");\nLOG_ERR(\"A log message in Error level!\");\n</code></pre>"},{"location":"#dumping-data","title":"Dumping data","text":"<p><code>LOG_HEXDUMP_X</code>  macros for dumping data where <code>X</code> can be <code>DBG</code>, <code>INF</code>, <code>WRN</code>, or <code>ERR</code>.</p> <pre><code>uint8_t data[] = {0x00, 0x01, 0x02, 0x03,\n                  0x04, 0x05, 0x06, 0x07,\n                  'H', 'e', 'l', 'l','o'};\nLOG_HEXDUMP_INF(data, sizeof(data),\"Sample Data!\");\n</code></pre>"},{"location":"#kconfig-logging-options","title":"Kconfig logging options","text":"LOG_MODE_DEFERRED Deferred mode is used by default. Log messages are buffered and processed later. This mode has the least impact on the application. Time-consuming processing is deferred to the known context. LOG_PROCESS_THREAD A thread is created by the logger subsystem (deferred mode). This thread is woken up periodically (LOG_PROCESS_THREAD_SLEEP_MS) or whenever the number of buffered messages exceeds the threshold (LOG_PROCESS_TRIGGER_THR). LOG_BACKEND_UART Send logs to the UART console. LOG_BACKEND_SHOW_COLOR Prints errors in red and warnings in yellow. Not all terminal emulators support this feature. LOG_BACKEND_FORMAT_TIMESTAMP Timestamp is formatted to <code>hh:mm:ss.ms,us</code>. LOG_MODE_OVERFLOW If there is no space to log a new message, the oldest one is dropped."},{"location":"#lesson-5","title":"Lesson 5","text":"<p>Learn how to use the UART driver in an interrupt-driven fashion so that when new data arrives the application is interrupted and a callback function (ISR) is called.</p> <p>Objectives</p> <ul> <li>Learn how to send/receive data over UART in asynchronous mode (interrupt-driven)</li> <li>Learn how to configure the UART peripheral hardware through the UART API</li> <li>Examine and practice the use of the UART driver API</li> </ul> <p>Data transfer is done serially. It starts with a starting bit, usually by driving logic low for one clock cycle. In the next n clock cycles, n bits are sent sequentially from the transmitter (n is usually 8). Optionally, 1 parity bit can be added to improve transfer reliability. In the end, the data wire is usually pulled up high to indicate the end of transfer.</p> <p>Parity bit: A parity bit describes the evenness or oddness of the data and is a way for the receiver to tell if the data has changed during transmission.</p>"},{"location":"#uart-driver","title":"UART Driver","text":"<p>In Zephyr, there are three different ways to access the UART peripheral, all with different API functions; polling, interrupts-driven and asynchronous.</p> <p>Polling - <code>uart_poll_in()</code> reading function and <code>uart_poll_out()</code> writing function. Asynchronous API - the most efficient way to use UART, it allows to read and write data in the background using EasyDMA.</p>"},{"location":"#enable-driver","title":"Enable driver","text":"<ol> <li> <p>Enable for use by adding <code>prj.conf</code></p> <pre><code>CONFIG_SERIAL=y\nCONFIG_UART_ASYNC_API=y\n</code></pre> </li> <li> <p>Include the header file</p> <pre><code>#include &lt;zephyr/drivers/uart.h&gt;\n</code></pre> </li> <li> <p>Create an instance of uart device structure</p> <pre><code>const struct device *uart = DEVICE_DT_GET(DT_NODELABEL(uart0));\nif (!device_is_ready(uart)) {\n   return;\n}\n</code></pre> <p>The pointer <code>uart</code> of type <code>struct device</code> is the structure that is used when interacting with the UART API.   On the other hand, <code>uart0</code> is the node label of the devicetree node that represents the UART hardware controller on the chip.</p> </li> </ol>"},{"location":"#uart-configurations","title":"UART Configurations","text":"<ol> <li> <p>Configuration of UART communication</p> <p>The default static configuration of the UART hardware is obtained from the devicetree.</p> <pre><code>const struct uart_config uart_cfg = {\n.baudrate = 115200,\n.parity = UART_CFG_PARITY_NONE,\n.stop_bits = UART_CFG_STOP_BITS_1,\n.data_bits = UART_CFG_DATA_BITS_8,\n.flow_ctrl = UART_CFG_FLOW_CTRL_NONE\n};\n\nint err = uart_configure(uart, &amp;uart_cfg);\n\nif (err == -ENOSYS) {\n   return -ENOSYS;\n}\n</code></pre> </li> <li> <p>Define callback function</p> <p>The callback function should have the following signature:</p> <pre><code>static void uart_cb(const struct device *dev, struct uart_event *evt, void *user_data)\n{\n   switch (evt-&gt;type)\n   {\n      case UART_TX_DONE:\n      // do something\n      break;\n      case UART_TX_ABORTED:\n      // do something\n      break;\n      case UART_RX_RDY:\n      // do something\n      break;\n      case UART_RX_BUF_REQUEST:\n      // do something\n      break;\n      case UART_RX_BUF_RELEASED:\n      // do something\n      break;\n      case UART_RX_DISABLED:\n      // do something\n      break;\n      case UART_RX_STOPPED:\n      // do something\n      break;\n      default:\n      break;\n   }\n}\n</code></pre> </li> <li> <p>Register the callback function by calling the function <code>uart_callback_set()</code>, which takes three parameters.</p> <pre><code>err = uart_callback_set(uart, uart_cb, NULL);\nif (err) {\n   return err;\n}\n</code></pre> </li> </ol>"},{"location":"#receive-data","title":"Receive data","text":"<ol> <li> <p>Declare a receive buffer to store the incoming data.</p> <pre><code>static uint8_t rx_buf[10] = {0}; //A buffer to store incoming UART data\n</code></pre> </li> <li> <p>To start receiving, call the uart_rx_enable() function, and pass the address of the receive buffer.</p> <pre><code>uart_rx_enable(uart, rx_buf, sizeof(rx_buf), 100);\n</code></pre> </li> <li> <p>The data received is accessible through the UART callback on the UART_RX_RDY event. <code>evt-&gt;data.rx.len</code>, <code>evt-&gt;data.rx.offset</code>, <code>evt-&gt;rx.buf[rx.offset]</code>, <code>evt-&gt;rx.buf[rx.offset+rx.len]</code></p> </li> <li> <p>Continuous reception is not enabled by default. Once the receive buffer is full, you must manually enable reception.</p> <pre><code>case UART_RX_DISABLED:\n   uart_rx_enable(dev, rx_buf, sizeof(rx_buf), 100);\n   break;\n</code></pre> </li> </ol>"},{"location":"#transmit-data","title":"Transmit data","text":"<ol> <li>Define a transmission buffer to hold the data to be sent.</li> </ol> <pre><code>static uint8_t tx_buf[] =  {\"nRF Connect SDK Fundamentals Course \\n\\r\"};\n</code></pre> <ol> <li>Call the function <code>uart_tx()</code> to send the data over UART.</li> </ol> <pre><code>err = uart_tx(uart, tx_buf, sizeof(tx_buf), SYS_FOREVER_US);\nif (err) {\n   return err;\n}\n</code></pre> <p>The function returns immediately and the sending is actually managed internally by the UART driver.</p> <p>If your application needs to take action once the whole transmission buffer is transmitted, you could do that by using the <code>UART_TX_DONE</code> event in the UART callback function.</p> <pre><code>case UART_TX_DONE:\n  // Do something here if needed  \n  break;\n</code></pre> <p>UART driver in nRF Connect SDK doesn't support interrupts. CTS stands for clear to send and is used when hardware flow control is enabled to receive the other module\u2019s RTS (ready to send) signal to indicate that it can begin sending data.</p>"},{"location":"#lesson-6","title":"Lesson 6","text":"<p>The basics of I2C and learn how to use the I2C driver in nRF.</p> <p>Objectives</p> <ul> <li>Learn how to use the I2C driver in nRF Connect SDK</li> <li>Practice using the I2C driver APIs through a hands-on exercise</li> <li>Communicate with an external sensor using the I2C bus</li> </ul>"},{"location":"#i2c-protocol","title":"I2C Protocol","text":"<p>Since it uses 2-wire, the I2C protocol is also known as the Two-Wire Interface (TWI).</p> <p>I2C controllers on Nordic\u2019s chips support multiple speeds: 100 (I2C_BITRATE_STANDARD), 400 (I2C_BITRATE_FAST) and 1000 (I2C_BITRATE_FAST_PLUS) kbps. The default speed is 100 kbps. I2C wires are called serial clock (SCL) and serial data (SDA)</p> <p>The SCL is generated by the I2C master to sync all devices on the bus to one clock, while the SDA line is bidirectional, so data can travel in either direction (from master to slave or slave to master).</p> <p>Each I2C slave device has a unique address that distinguishes it from the other I2C slave devices on the same bus. The address is usually a 7-bit value, however, some I2C slave devices also use a 10-bit value.</p>"},{"location":"#i2c-driver","title":"I2C Driver","text":"<ol> <li> <p>Enable driver in <code>prj.conf</code></p> <pre><code>CONFIG_I2C=y\n</code></pre> </li> <li> <p>Include header of the I2C API in your source code file.</p> <pre><code>#include &lt;zephyr/drivers/i2c.h&gt;\n</code></pre> </li> <li> <p>Specify which I2C controller your device (sensor) is connected to and its I2C address.</p> <p>If the sensor is not already defined in the board\u2019s devicetree, you need to manually add your sensor as a child devicetree node to the i2c   controller, using a devicetree overlay file.</p> <p>3.1 Create overlay files.</p> <p>From the details panel, expand Input files and create an overlay file.   This will create an empty overlay file in your application root directory.</p> <p>3.2 In the overlay file, specify the I2C controller that your sensor is connected to and its address.</p> <p>At a minimum, you need to specify the compatible, the address of the i2c target device, and its label.</p> <pre><code>&amp;i2c0 {\n   mysensor: mysensor@4a{\n      compatible = \"i2c-device\";\n      reg = &lt; 0x4a &gt;;\n      label = \"MYSENSOR\";\n   };\n};\n</code></pre> </li> <li> <p>Define the node identifier.</p> <p>Use devicetree macro <code>DT_NODELABEL()</code> to get the node identifier symbol <code>I2C0_NODE</code>, which will represent the I2C hardware controller <code>i2c0</code>.</p> <pre><code>#define I2C0_NODE DT_NODELABEL(mysensor)\n</code></pre> </li> <li> <p>Retrieve the API-specific device structure.</p> <p>Macro call <code>I2C_DT_SPEC_GET()</code> returns the structure <code>i2c_dt_spec</code>, which contains the device pointer for the I2C bus, as well as the target address.</p> <pre><code>static const struct i2c_dt_spec dev_i2c = I2C_DT_SPEC_GET(I2C0_NODE);\n</code></pre> </li> <li> <p>Use <code>device_is_ready()</code> to verify that the device is ready to use.</p> <pre><code>if (!device_is_ready(dev_i2c.bus)) {\n   printk(\"I2C bus %s is not ready!\\n\\r\",dev_i2c.bus-&gt;name);\n   return;\n}\n</code></pre> </li> </ol>"},{"location":"#i2c-write","title":"I2C Write","text":"<pre><code>uint8_t config[2] = {0x03,0x8C};\nret = i2c_write_dt(&amp;dev_i2c, config, sizeof(config));\nif(ret != 0){\n printk(\"Failed to write to I2C device address %x at reg. %x n\", dev_i2c-&gt;addr,config[0]);\n}\n</code></pre>"},{"location":"#i2c-read","title":"I2C Read","text":"<pre><code>uint8_t data;\nret = i2c_read_dt(&amp;dev_i2c, &amp;data, sizeof(data));\nif(ret != 0){\n printk(\"Failed to read from I2C device address %x at Reg. %x n\", dev_i2c-&gt;addr,config[0]);\n}\n</code></pre>"},{"location":"#i2c-writeread","title":"I2C Write/Read","text":"<pre><code>uint8_t sensor_regs[2] ={0x02,0x00};\nuint8_t temp_reading[2]= {0};\nint ret = i2c_write_read_dt(&amp;dev_i2c,&amp;sensor_regs[0],1,&amp;temp_reading[0],1);\nif(ret != 0){\n printk(\"Failed to write/read I2C device address %x at Reg. %x n\", dev_i2c-&gt;addr,sensor_regs[0]);\n}\n</code></pre> <p>Writing and subsequently reading is a common operation in the I2C protocol because you need to write the register you want to read from before reading.</p>"},{"location":"#lesson-7-multithreaded-applications","title":"Lesson 7 - Multithreaded applications","text":"<p>How to create threads with different priorities and learn about the scheduler\u2019s behavior through features like time slicing and workqueues in Zephyr RTOS.</p> <p>Objectives:</p> <ul> <li>Understand the main difference between bare-metal vs RTOS programming, including both advantages and disadvantages in utilizing an RTOS</li> <li>Get familiarized with Zephyr RTOS execution model, ISRs, threads, thread\u2019s life-cycle and inter-task communication/synchronization mechanisms, and the scheduler</li> <li>Learn the basics of kernel services related to threads (user-defined threads, system threads, workqueue threads)</li> <li>Learn about preemptive scheduling and time-slicing through hands-on exercises</li> <li>Practice through hands-on exercises how to create threads, thread yielding and sleeping</li> <li>Practice through hands-on exercises how to offload work to a workqueue</li> </ul>"},{"location":"#bare-metal-vs-rtos-based-application","title":"Bare-metal vs RTOS-based application","text":"<p>RTOS applications allow for multiple concurrent logics while bare-metal applications runs sequential logic.</p>"},{"location":"#bare-metal","title":"Bare-metal","text":"<p>A bare-metal application, at its core, is just a big loop in the main function right after you have initialized the hardware/software at the device powerup/reset routines. All the execution is sequential logic, in other words, all instructions are executed in sequence unless interrupted by an interrupt service routine (ISR). So the only non-sequential logic you have in bare-metal programming makes use of exceptions.</p> <p>In general, a bare-metal program is typically more power-efficient, uses less memory, and in some situations runs faster. For applications with simple to average complexity, it is a good enough solution to have one sequential logic in a loop. Especially considering bare-metal programs are more power-efficient and use less memory. However, your application can very easily get quite complex in terms of maintaining the architecture as sequential logic. This is where using a real-time operating system (RTOS) becomes advantageous.</p>"},{"location":"#rtos","title":"RTOS","text":"<p>Designing your application on top of an operating system allows you to have multiple concurrent logics in your application running in different execution units called threads, making your architecture simple, as opposed to just one sequential logic running in your main function in standalone mode.</p> <p>The core of an RTOS is called the kernel and controls everything in the system. The other big added advantage is the huge resources of libraries, drivers, and protocol stacks that are natively available by an RTOS like Zephyr.</p> <p>Interrupt Service Routines (ISRs) are available in both RTOS-based applications and bare-metal applications. They are generated asynchronously by the different devices drivers configured(including callback functions) and protocols stacks.</p> <p>Having the main() function is optional in Zephyr RTOS-based applications. This is because the main thread automatically spawned by the RTOS will do the necessary RTOS initialization, including scheduler/kernel setup, and core drivers setup.</p>"},{"location":"#zephyr-rtos-basics","title":"Zephyr RTOS basics","text":""},{"location":"#threads","title":"Threads","text":"<p>A thread is the smallest logical unit of execution for the RTOS scheduler (covered later in this topic) that is competing for the CPU time.</p> <ul> <li> <p>Running: The running thread is the one that is currently being executed by the CPU.</p> </li> <li> <p>Runnable: A thread is marked as \u201cRunnable\u201d when it has no other dependencies with other threads or other system resources to proceed further in execution. The only resource this thread is waiting for is the CPU time, also known as \u201cReady\u201d state.</p> </li> <li> <p>Non-runnable: A thread that has one or more factors that prevent its execution is deemed to be unready, and cannot be selected as the current thread. This can, for example, be because they are waiting for some resource that is not yet available or they have been terminated or suspended, also known as \u201cUnready\u201d state.</p> </li> </ul>"},{"location":"#system-threads","title":"System threads","text":"<p>Thread that is spawned automatically by Zephyr RTOS during initialization.</p> <ul> <li> <p>Main thread - executes the necessary RTOS initializations and calls the application\u2019s main() function, if it exists.</p> </li> <li> <p>Idle thread - runs when there is no other work to do.</p> </li> </ul>"},{"location":"#user-created-threads","title":"User-created threads","text":"<p>User can define their own threads to assign tasks to. For example, a user can create a thread to delegate reading sensor data, another thread to process data, and so on.</p>"},{"location":"#workqueue-threads","title":"Workqueue threads","text":"<p><code>Common execution unit</code> in <code>nRF Connect SDK</code> is a <code>work item</code>, which is nothing more than a user-defined function that gets called by a dedicated thread called a <code>workqueue thread</code>.</p> <p>The main use of this is to offload non-urgent work from an ISR or a high-priority thread to a lower priority thread. You do not need to create and initialize a workqueue if submitting work items to the system workqueue. ISR or high priority thread submits work into a workqueue, and the dedicated workqueue thread pulls out a work item in a first in, first out (FIFO) order.</p>"},{"location":"#threads-priority","title":"Threads Priority","text":"<p>Threads are assigned an integer value to indicate their priority, which can be either negative or non-negative.</p> <p>A thread with a <code>negative priority</code> is classified as a <code>cooperative thread</code> (<code>CONFIG_NUM_COOP_PRIORITIES</code> and is, by default, equal to 16). Thread with a <code>non-negative priority</code> is classified as a <code>preemptible thread</code> (<code>CONFIG_NUM_PREEMPT_PRIORITIES</code> and is, by default, equal to 15).</p>"},{"location":"#scheduler","title":"Scheduler","text":"<p>The scheduler is the part of the RTOS responsible for scheduling which tasks are running, i.e using CPU time, at any given time. It does this using a scheduling algorithm to determine which task should be the next to run.</p>"},{"location":"#rescheduling-point","title":"Rescheduling point","text":"<p>Zephyr RTOS is by default a tickless RTOS. A tickless RTOS is completely event-driven, which means that instead of having periodic timer interrupts to wake up the scheduler, it is woken based on events known as rescheduling points.</p> <p>Rescheduling points are:</p> <ul> <li>When a thread calls <code>k_yield()</code>, the thread\u2019s state is changed from \u201cRunning\u201d to \u201cReady\u201d.</li> <li>Unblocking a thread by giving/sending a kernel synchronization object like a semaphore, mutex or alert, causes the thread\u2019s state to be changed from \u201cUnready\u201d to \u201cReady\u201d.</li> <li>When a receiving thread gets new data from other threads using data passing kernel objects, the data receiving thread\u2019s state is changed from \u201cWaiting\u201d to \u201cReady\u201d.</li> <li>When time slicing is enabled and the thread has run continuously for the maximum time slice time allowed, the thread\u2019s state is changed from \u201cRunning\u201d to \u201cReady\u201d.</li> </ul>"},{"location":"#isr","title":"ISR","text":"<p>Interrupt Service Routines (ISRs) are generated asynchronously by the device drivers and protocol stacks. They are not scheduled (This includes callback functions). ISRs preempt the execution of the current thread, allowing the response to occur with very low overhead.</p>"},{"location":"#create-application-with-threads","title":"Create application with threads","text":"<ol> <li> <p>Define the stack size and scheduling priority of the two threads that we will use when defining them.</p> <pre><code>#define STACKSIZE 1024 // Stack sizes should always be a power of two (512, 1024, 2048, etc.).\n#define THREAD0_PRIORITY 7\n#define THREAD1_PRIORITY 7\n</code></pre> </li> <li> <p>Define the threads</p> <pre><code>void thread1(void)\n{\nwhile (1) {\n   printk(\"Hello, I am thread1\\n\");\n\n   k_yield(); // Set to lower priority and allow to run other threads\n   // OR set thread to sleep\n   //k_msleep(5);\n   }\n}\n// ...\n</code></pre> </li> <li> <p>Initialize threads</p> <pre><code>K_THREAD_DEFINE(thread0_id, STACKSIZE, thread0, NULL, NULL, NULL,\n      THREAD0_PRIORITY, 0, 0);\nK_THREAD_DEFINE(thread1_id, STACKSIZE, thread1, NULL, NULL, NULL,\n      THREAD1_PRIORITY, 0, 0);\n</code></pre> </li> <li> <p>If threads cannot sleep or yield, enable timeslicing in prj.conf to prevent starvation</p> <p>The scheduler will preempt the running thread after the configured amount of time (10 ms in this case) regardless of what it is doing</p> <pre><code>CONFIG_TIMESLICING=y\nCONFIG_TIMESLICE_SIZE=10\nCONFIG_TIMESLICE_PRIORITY=0\n</code></pre> <p>The scheduler will check and preempt only equal priority thread, thus if we will use code below, thread0 will starve thread1 forever</p> <pre><code>#define THREAD0_PRIORITY 6\n#define THREAD1_PRIORITY 7\n</code></pre> </li> </ol>"},{"location":"#workqueue-creation","title":"Workqueue creation","text":"<ol> <li> <p>Define threads with different priorities</p> <pre><code>#define THREAD0_PRIORITY 2 \n#define THREAD1_PRIORITY 3\n#define WORKQ_PRIORITY   4\n</code></pre> </li> <li> <p>Create threads with delta times</p> <pre><code>static inline void emulate_work()\n{\n   for(volatile int count_out = 0; count_out &lt; 150000; count_out ++);\n}\n\nvoid thread0(void)\n{\n   uint64_t time_stamp;\n   int64_t delta_time;\n   while (1) {\n      time_stamp = k_uptime_get();\n      emulate_work();\n      delta_time = k_uptime_delta(&amp;time_stamp);\n      printk(\"thread0 yielding this round in %lld ms\\n\", delta_time);\n      k_msleep(20);\n   }\n}\n</code></pre> <p>Offload work from high priority task if necessary</p> <pre><code>struct work_info {\n   struct k_work work;\n   char name[25];\n} my_work;\n\nvoid offload_function(struct k_work *work_tem)\n{\n   emulate_work();\n}\n\nk_work_queue_start(&amp;offload_work_q, my_stack_area,\n                  K_THREAD_STACK_SIZEOF(my_stack_area), WORKQ_PRIORITY,\n                  NULL);\nstrcpy(my_work.name, \"Thread0 emulate_work()\");\nk_work_init(&amp;my_work.work, offload_function);\n\nk_work_submit_to_queue(&amp;offload_work_q, &amp;my_work.work);\n</code></pre> </li> </ol>"},{"location":"#lesson-8-thread-synchronization","title":"Lesson 8 - Thread synchronization","text":"<p>Need for thread synchronization and how to use semaphores and mutexes as thread synchronization mechanisms.</p> <p>Objective:</p> <ul> <li>Understand the need for thread synchronization mechanisms</li> <li>Learn the basic properties of semaphores and mutexes</li> <li>Practice through hands-on exercises how to use semaphores and mutexes for thread synchronization</li> </ul> <p>If more than one thread tries to access the same piece of code simultaneously, usually referred to as the critical section, this can lead to unexpected or erroneous behavior. Two mechanisms you can utilize to achieve thread synchronization are semaphores or mutexes.</p> <ul> <li>Semaphores have a maximum value that is set at initialization</li> <li>Mutexes have ownership property, i.e only the thread incrementing its value can decrement it, until zero when it is relinquished.</li> </ul>"},{"location":"#semaphores","title":"Semaphores","text":"<p>In its simplest form, a semaphore is merely a plain variable that is changed, indicating the status of the common resource. Semaphores can be seen as a resource-sharing mechanism, where you have a finite instance of a resource that you want to manage access for multiple threads. They are more of a signaling mechanism used to control access to a given number of instances of a resource.</p> <p>Semaphores have the following properties:</p> <ul> <li>At initialization, you set an initial count (greater than 0) and a maximum limit.</li> <li>\u201cGive\u201d will increment the semaphore count unless the count is already at the maximum limit, in which case the signal will not increment. \u201cGive\u201d can be done from any thread or ISR.</li> <li>\u201cTake\u201d will decrement the semaphore count unless the semaphore is unavailable (count at zero). Any thread that is trying to take a semaphore that is unavailable needs to wait until some other thread makes it available (by giving the semaphore). \u201cTake\u201d can be done only in threads and not in ISR (since ISRs should not block on anything).</li> <li>There is no ownership of semaphores. This means a semaphore can be taken by one thread and can be given by any thread. It is not necessary that the thread that has taken the semaphore is the one to give it.</li> <li>The thread taking the semaphore is NOT eligible for priority inheritance since the taking thread does not own the semaphore and any other thread can give the semaphore.</li> </ul> <p></p>"},{"location":"#mutexes","title":"Mutexes","text":"<p>As opposed to semaphores, mutexes can only take two values, commonly referred to as locked or unlocked. Additionally, mutexes have ownership properties in the sense that only the thread that locks the mutex can unlock it. Think of it as a locking/unlocking mechanism with a single key, where a thread wishing to gain access to a single object. For instance, a code section or a resource needs to first gain access to an unlocked mutex, lock it and then access the object. If the thread trying to gain access to the mutex sees that the mutex is already locked, then the thread gets blocked and will wait until the mutex is unlocked by the thread that locked it.</p> <p>A typical use of a mutex is to protect a critical section of the code that can be accessed from multiple threads. The critical section is a piece of code that needs to be completed without interruptions from other threads, or else the global/static data within that critical section could be misrepresented or get corrupted</p> <p>Mutexes have the following properties:</p> <ul> <li>Locking a mutex will increment the lock count. Recursive locking (reentrant locking) will not make the locking thread block since it already owns  the mutex. The thread should make sure that it unlocks the mutex the same number of times that it locked it to release the mutex so that other threads  can attempt to own it.</li> <li>Unlocking a mutex will decrement the lock count. When the lock count is zero, that means that the mutex is in an unlocked state. Threads can attempt to own the mutex only when the mutex is in an unlocked state.</li> <li>Only the thread that locked the mutex can unlock it.</li> <li>Mutexes locking and unlocking can only be done in threads and not in ISRs. This is because ISRs cannot participate in the ownership and priority inheritance mechanism of the scheduler.</li> <li>The thread locking the mutex is eligible for priority inheritance since only that thread can unlock the mutex.</li> </ul> <p></p>"},{"location":"#use-semaphores","title":"Use semaphores","text":"<ol> <li> <p>Set the priority of the producer and consumer thread.</p> <pre><code>#define PRODUCER_PRIORITY        5 \n#define CONSUMER_PRIORITY        4\n</code></pre> </li> <li> <p>Initialize the number of instances of the limited resource to be 10 (just assume that we have 10 instances of that resource).</p> <pre><code>volatile uint32_t available_instance_count = 10;\n</code></pre> </li> <li> <p>Create the producer thread that just releases the resource without any checks and sleeps for a random (500-509ms) amount of time. When it wakes up from this sleep, it repeats this step in a loop indefinitely.</p> <pre><code>void producer(void)\n{\n   printk(\"Producer thread started\\n\");\n   while (1) {\n      release_access();\n      // Assume the resource instance access is released at this point\n      k_msleep(500 + sys_rand32_get() % 10);\n   }\n}\n</code></pre> </li> <li> <p>Create the consumer thread that gets access to the resource without any checks and assumes to get access before it goes to sleep for a random (0-9ms) amount of time. When it wakes up, it repeats this step in a loop indefinitely.</p> <pre><code>void consumer(void)\n{\n   printk(\"Consumer thread started\\n\");\n   while (1) {\n      get_access();\n      // Assume the resource instance access is released at this point\n      k_msleep(sys_rand32_get() % 10);\n   }\n}\n</code></pre> </li> <li> <p>Decrement the available resource in <code>get_access()</code> function.</p> <pre><code>available_instance_count--;\nprintk(\"Resource taken and available_instance_count = %d\\n\",  available_instance_count);\n</code></pre> </li> <li> <p>Increase the available resource in <code>release_access()</code> function.</p> <pre><code>available_instance_count++;\nprintk(\"Resource given and available_instance_count = %d\\n\", available_instance_count);\n</code></pre> <p><code>If you compile and build project here - count will print negative numbers (which shouldnt happen with physical resource)</code></p> </li> <li> <p>Add a semaphore by first defining the semaphore using <code>K_SEM_DEFINE()</code></p> <pre><code>K_SEM_DEFINE(instance_monitor_sem, 10, 10);\n</code></pre> </li> <li> <p>Before accessing the resource, take the semaphore using <code>k_sem_take()</code> in <code>get_access()</code>.</p> <pre><code>k_sem_take(&amp;instance_monitor_sem, K_FOREVER);\n</code></pre> </li> <li> <p>After finishing accessing the resource release the semaphore using <code>k_sem_give()</code> in <code>release_access()</code>.</p> <pre><code>k_sem_give(&amp;instance_monitor_sem);\n</code></pre> </li> </ol> <p><code>Consumer</code> thread starts accessing all of the 10 resources very quickly but is forced to wait when the resource count becomes 0. The <code>consumer</code> thread is then blocked until the <code>producer</code> thread gives the semaphore and the resource becomes available, unblocking the <code>consumer</code> thread.</p>"},{"location":"#use-mutexes","title":"Use mutexes","text":"<p>Two threads running and accessing the same code section of code. The logic looks perfect when only one thread is accessing the critical section, but when two different threads try to access the code section simultaneously, unexpected things happen(Race condition).</p> <ol> <li> <p>Enable multithreading in the application in prj.conf (This configuration defaults to yes in all nRF Connect SDK applications and isn\u2019t strictly necessary to enable manually);</p> <pre><code>CONFIG_MULTITHREADING=y\n</code></pre> </li> <li> <p>Set the priority of threads to have equal priority.</p> <pre><code>#define THREAD0_PRIORITY        4 \n#define THREAD1_PRIORITY        4\n</code></pre> </li> <li> <p>Create the functions for the two threads.</p> <pre><code>void thread0(void)\n{\n   printk(\"Thread 0 started\\n\");\n   while (1) {\n      shared_code_section();\n   }\n}\nvoid thread1(void)\n{\n   printk(\"Thread 1 started\\n\");\n   while (1) {\n      //shared_code_section(); \n   }\n}\n</code></pre> </li> <li> <p>Define variables and implement logic in <code>shared_code_section()</code>.</p> <pre><code>#define COMBINED_TOTAL   40\nint32_t increment_count = 0;\nint32_t decrement_count = COMBINED_TOTAL;\n\nvoid shared_code_section(){\n   increment_count += 1;\n   increment_count = increment_count % COMBINED_TOTAL;\n   decrement_count -= 1;\n   if (decrement_count == 0)\n   {\n      decrement_count = COMBINED_TOTAL;\n   }\n}\n</code></pre> </li> <li> <p>Check for <code>race condition</code> in shared_code_section.</p> <pre><code>if(increment_count + decrement_count != COMBINED_TOTAL )\n   {\n      printk(\"Race condition happend!\\n\");\n      printk(\"Increment_count (%d) + Decrement_count (%d) = %d \\n\",\n                  increment_count, decrement_count, (increment_count + decrement_count));\n      k_msleep(400 + sys_rand32_get() % 10);\n   }\n</code></pre> <p><code>If you compile and build project here - race condition will not happen, as thread1 is commented</code></p> </li> <li> <p>let thread1 access <code>shared_code_section()</code></p> <pre><code>void thread1(void)\n{\n   printk(\"Thread 1 started\\n\");\n   while (1) {\n      shared_code_section();\n   }\n}\n</code></pre> <p><code>If you compile and build project here - race condition will happen</code></p> </li> <li> <p>Define <code>mutex</code></p> <pre><code>K_MUTEX_DEFINE(test_mutex);\n</code></pre> </li> <li> <p>Lock mutex before logic in <code>shared_code_section()</code></p> <pre><code>k_mutex_lock(&amp;test_mutex, K_FOREVER);\n</code></pre> </li> <li> <p>Unlock it right before if-statement checking race condition.</p> <pre><code>k_mutex_unlock(&amp;test_mutex);\n</code></pre> </li> </ol>"},{"location":"ble/","title":"Bluetooth Low Energy","text":"<p>Zephyr Bluetooth Host</p> <p>nRF Sniffer</p> <p>Wireshark</p>"},{"location":"ble/#fundamentals","title":"Fundamentals","text":""},{"location":"ble/#host","title":"Host","text":"<p>The Bluetooth LE host consists of the following layers:</p> <ul> <li>Logical Link Control &amp; Adaptation Protocol (L2CAP): provides data encapsulation services to the upper layers.</li> <li>Security Manager Protocol (SMP): defines and provides methods for secure communication.</li> <li>Attribute Protocol (ATT): allows a device to expose certain pieces of data to another device.</li> <li>Generic Attribute Profile (GATT): defines the necessary sub-procedures for using the ATT layer.</li> <li>Generic Access Profile (GAP): interfaces directly with the application to handle device discovery and connection-related services.</li> </ul> <p>The Zephyr Bluetooth Host implements all these layers and provides an API for applications.</p>"},{"location":"ble/#controller","title":"Controller","text":"<p>The Bluetooth LE controller is comprised of the following layers:</p> <ul> <li>Physical Layer (PHY): determines how the actual data is modulated onto the radio waves, and how it is transmitted and received.</li> <li>Link Layer (LL): manages the state of the radio, defined as one of the following \u2013 standby, advertising, scanning, initiating, connection.</li> </ul>"},{"location":"ble/#definitions","title":"Definitions","text":"<ul> <li>Advertising: The process of transmitting advertising packets, either just to broadcast data or to be discovered by another device.</li> <li>Scanning: The process of listening for advertising packets.</li> <li>Central: A device role that scans and initiates connections with peripherals.</li> <li>Peripheral: A device role that advertises and accepts connections from centrals.</li> <li>Broadcaster: A special kind of peripheral that broadcasts advertisement packets without accepting any connection requests.</li> <li>Observer: A special kind of central that listens to advertising packets without initiating a connection.</li> </ul>"},{"location":"ble/#network-topologies","title":"Network topologies","text":"<ul> <li><code>Broadcast</code> data transfer happens without the devices ever establishing a connection. This is done by using the advertisement packets to broadcast the data to any device that is in range to receive the packets.</li> <li><code>Connected</code> network topology establishes a connection before data transfer occurs. Unlike the broadcast topology, the communication is now bidirectional.</li> <li><code>Multi-role</code> A single device can also operate in multiple different roles simultaneously. For instance, the same device can act as a peripheral in one setting, and a central in another.</li> </ul>"},{"location":"ble/#att-gatt","title":"ATT &amp; GATT","text":"<ul> <li>Attribute Protocol - ATT layer is the basis on which data is transmitted, received, and handled in the connection phase of Bluetooth LE devices. It is based on a client-server architecture.</li> <li>GATT server: Device that stores data and provides methods for the GATT client to access the data.</li> <li>GATT client: Device that accesses the data on the GATT server, through specific GATT operations which will be explained in Lesson 4.</li> <li> <p>Attribute: A standardized data representation format defined by the ATT protocol</p> </li> <li> <p>Generic Attribute Profile - GATT layer sits directly on top of the ATT layer, and builds on it by hierarchically classifying attributes into profiles, services and characteristics. The GATT layer uses these concepts to govern the data transfer between Bluetooth LE devices.</p> </li> </ul> <p></p>"},{"location":"ble/#phy-physical-layer","title":"PHY - Physical Layer","text":"<ul> <li>1M PHY - classic 1 Megabit PHY supported by all Bluetooth</li> <li>2M PHY - 2 Megabit PHY is supported Bluetooth v5.0, decreased battery usage with less communication range</li> <li>Coded PHY - longer communication range by sacrificing data rate</li> </ul>"},{"location":"ble/#advertising-types","title":"Advertising types","text":"<ul> <li>Connectable vs. non-connectable: Determines whether the central can connect to the peripheral or not.</li> <li>Scannable vs. non-scannable: Determines if the peripheral accepts scan requests from a scanner.</li> <li>Directed vs. undirected: Determines whether advertisement packets are targeted to a specific scanner or not.</li> </ul> <p><code>Scannable and connectable (ADV_IND)</code> <code>Directed connectable (ADV_DIRECT_IND)</code> <code>Non-connectable and scannable (ADV_SCAN_IND)</code> <code>Non-connectable and non-scannable (ADV_NONCONN_IND)</code></p>"},{"location":"ble/#advertisement-packet","title":"Advertisement packet","text":"<p>Protocol Data Unit (PDU) consists of either an advertising PDU (advertising channel PDU) or a data PDU (channel PDU)</p> <p></p> <p>The advertisement payload structure depends on the kind of advertising being used. For example, when doing directed advertisement, some space is needed to also specify the receiver\u2019s address.</p>"},{"location":"ble/#connection-process","title":"Connection process","text":"<p>When the central sends a connection request, the peripheral and central have established a bi-directional connection (connection-oriented) channel.</p> <p>connection interval in Bluetooth LE - The interval at which the devices wake up to exchange data</p>"},{"location":"ble/#disconnected-by-supervision-timeout","title":"Disconnected by supervision timeout","text":"<p>The other reason a device may disconnect is if it stops responding to packets. There can be several reasons for this. Either the application on the connected device crashed and reset (which is not too uncommon, especially during the development phase), the connected device ran out of battery, or the connected device was taken out of radio range. The amount of time it takes before the connection times out is set by the connection supervision timeout parameter, which we will discuss in more detail in the next topic.</p> <ul> <li>The <code>MTU</code> is the number of bytes that can be sent in one GATT operation (for example, a send operation), while <code>data length</code> is the number of bytes that can be sent in one Bluetooth LE packet. <code>MTU</code> has a default value of <code>23 bytes</code>, and <code>data length</code> has a default value of <code>27 bytes</code>.</li> </ul>"},{"location":"ble/#data-exchange-in-bluetooth-le","title":"Data exchange in Bluetooth LE","text":"<p>Closer look at the Generic Attribute Protocol (GATT), its underlayer Attribute Protocol (ATT). Learn how to represent and exchange data between two connected Bluetooth LE devices using different GATT operations.</p>"},{"location":"ble/#client-initiated-operations","title":"Client-initiated operations","text":"<p>GATT operations where the client requests data from the GATT server.</p> <p>Operation used byclient to retrieve services: service discovery,service discovery operation,discovery</p> <ul> <li>Read - read request to the server. To which the server responds by returning the attribute value.</li> <li>Write - sends a write request and provides data that matches the same format of the target attribute. If the server accepts the write operation, it responds with an acknowledgement.</li> <li>Write without response - client can write data to an attribute without waiting for an acknowledgment from the server.</li> </ul>"},{"location":"ble/#server-initiated-operations","title":"Server-initiated operations","text":"<p>These operations are initiated by the server, but the client is required to enable them first by subscribing to the characteristic and enabling either notifications or indications.</p> <ul> <li>Notify - server automatically push the value of a certain attribute to the client, without the client asking for it.</li> <li>Indicate - Indicate will also push the attribute value directly to the client. However, in this case, an acknowledgment from the client is required (for this you can only send one Indication per connection interval)</li> </ul>"},{"location":"ble/#services-and-characteristics","title":"Services and characteristics","text":"<p>ATT layer defines attributes and how data is exposed between a client and a server.</p>"},{"location":"ble/#attributes","title":"Attributes","text":"<p>ATT layer defines how data is stored and accessed in a server\u2019s database. Data is stored in the form of data structures called Attributes.</p> <p></p> <ul> <li>Handle: A 16-bit unique index to a specific attribute in the attribute table, assigned by the stack.</li> <li>Type (UUID): Universally unique ID (UUID), which tells us the attribute type.</li> <li>Permissions: The security level required (encryption and/or authorization) to handle that attribute, in addition to indicating whether it\u2019s a readable and/or writeable attribute.</li> <li>Value:</li> <li>User data (ex: sensor reading) that is stored in the attribute. This field accepts any data type.</li> <li>It can also hold information (metadata) about another attribute.</li> </ul>"},{"location":"ble/#universally-unique-id-uuid","title":"Universally unique ID (UUID)","text":"<p>It is a unique number used to identify attributes and tells us about their significance. UUIDs have two types.</p> <ul> <li>SIG-defined 16-bit UUID.</li> <li>128-bit UUID, sometimes referred to as a vendor-specific UUID. This is the type of UUID you need to use when you are making your own custom services and characteristics.</li> </ul>"},{"location":"ble/#services","title":"Services","text":"<p>Attributes are the main building blocks for services.</p> <ul> <li>service definition - is comprised of multiple attributes arranged in a GATT-specified format which facilitates standardized data exchange between Bluetooth LE devices. Service definitions always start with a service declaration attribute.</li> <li>service declaration attribute - holds metadata about the service, it also indicates the beginning of a service in the sequence of services stored on a GATT server.</li> <li>characteristic declaration attribute - characteristic is comprised of at least two attributes and optionally more. Characteristic definition starts with a declaration attribute, to indicate the beginning of a characteristic in the sequence of characteristics in a service definition attributes:</li> </ul> <p></p> <ul> <li>Characteristic declaration attribute: Holds metadata about the Characteristic Value Attribute.<ul> <li>Characteristic properties: What kind of GATT operations are permitted on this characteristic.</li> <li>Characteristic value handle: The handle (address) of the attribute that contains the user data (value), i.e the characteristic value attribute.</li> <li>Characteristic UUID: The UUID of the characteristic being declared.</li> </ul> </li> <li>Characteristic value attribute: Holds the actual user data.</li> <li>Characteristic descriptor attribute (optional): Holds more metadata about the characteristic (GATT-defined Client Characteristic   Configuration Descriptor (CCCD) is the most commonly used)<ul> <li>CCCD is a specific type of characteristic descriptor that is necessary when the characteristic supports server-initiated operations (i.e Notify and Indicate). This is a writable descriptor that allows the GATT client to enable and disable notifications or indications for that characteristic.</li> </ul> </li> </ul> <p>A service can have zero or more characteristic definitions (commonly referred to as characteristics). A characteristic is comprised of at least two attributes and optionally more.</p>"},{"location":"ble/#security-in-ble","title":"Security in BLE","text":"<ul> <li>Pairing: The process of generating, distributing, and authenticating keys for encryption purposes.</li> <li>Bonding: The process of pairing followed by distribution of keys used to encrypt the link in future reconnections.</li> </ul>"},{"location":"ble/#pairing","title":"Pairing","text":"<ul> <li>Initiation: send pairing request (only contral), peripheral sends pairing response (<code>Security Request</code> or <code>I/O capabilities</code>: DisplayOnly/DisplayTesNo/KeyboardOnly/NoInputNoOutput/KeyboardDispay)</li> <li>Perform pairing: Just Works (plain text, unauthenticated), Passkey Entry (6-digit), Out of Band, Numeric Comparison)</li> <li>Key distribution: LTK (Long Term Key) is used to distribute the rest of the keys</li> </ul>"},{"location":"ble/#legacy-pairing","title":"Legacy Pairing","text":"<p>Prior to Bluetooth v4.2. STK (Short Term Key) encrypting link can be easly cracked (999999 combinations) and have no MITM protection.</p>"},{"location":"ble/#le-secure-connections","title":"LE Secure Connections","text":"<p>Use Elliptic-Curve Diffie-Hellman (ECDH) cryptography to generate a public-private key pair. They will use one of the four pairing methods (Just Works, Passkey entry, OOB or Numeric Comparison) The only data exchanged between the peers is the public keys. The use of the ECDH public key cryptography makes it extremely difficult to crack the LTK</p>"},{"location":"ble/#security-concerns","title":"Security concerns","text":"<ul> <li>Identity tracking</li> <li>Sniffing (Passive eavesdropping)</li> <li>MITM (Active eavesdropping - Man-In-The-Middle attack)</li> </ul>"},{"location":"ble/#security-levels","title":"Security Levels","text":"<ol> <li>No security (open text, meaning no authentication and no encryption)</li> <li>Encryption with unauthenticated pairing (Just Works)</li> <li>Authenticated pairing with encryption (Passkey entry or OOB)</li> <li>Authenticated LE Secure Connections pairing with encryption</li> </ol> <p><code>Permissions</code> field  of <code>attribute</code> - determines security level of connection if accesible</p>"},{"location":"ble/#filter-accept-list","title":"Filter Accept List","text":"<p>Accepting only connection from whitelist</p>"},{"location":"ble/#ble-sniffer","title":"BLE Sniffer","text":"<p>Intercept the Bluetooth LE packets as they are transmitted, ie. \u201csniff\u201d the packets, and view them in real-time.</p> <p>After WireShark installation, download nRF sniffer and configure it: configuration instruction </p> <p></p>"},{"location":"briefcode/","title":"Brief of all code/config","text":"<p>Collapse All/Expand All Code</p>"},{"location":"briefcode/#paths","title":"~PATHs","text":"<p>Device tree file</p> <pre><code>&lt;install_path&gt;\\zephyr\\boards\\arm\\&lt;board_name&gt;\n</code></pre>"},{"location":"briefcode/#cmakeliststxt","title":"<code>CMakeLists.txt</code>","text":"<pre><code>cmake_minimum_required(VERSION 3.20.0)\nfind_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})\nproject(nrf_connect_sdk_fundamentals)\n\ntarget_sources(app PRIVATE src/main.c)\n# target_sources_ifdef(CONFIG_MYFUNCTION app PRIVATE src/myfunction.c) # myfunction.c (in this case) in the same folder as main.c\n</code></pre> myfunction.c &amp; myfunction.h <ul> <li>myfunction.c</li> </ul> <pre><code>#include \"myfunction.h\"\n\nint sum(int a, int b){\n    return a+b;\n}\n</code></pre> <ul> <li>myfunction.h</li> </ul> <pre><code>#ifndef MY_FUNCTION_H\n#define MY_FUNCTION_H\n\nint sum(int a, int b);\n\n#endif\n</code></pre>"},{"location":"briefcode/#prjconf","title":"<code>prj.conf</code>","text":"<pre><code>## IO\nCONFIG_GPIO=y\nCONFIG_SERIAL=y                 ##Enable the serial driver in asynchronous mode \nCONFIG_UART_ASYNC_API=y         # \u2191\nCONFIG_I2C=y                    # Enable the I2C driver\n\nCONFIG_CBPRINTF_FP_SUPPORT=y    # Enable floating point format specifiers\nCONFIG_PRINTK=y                 # Enable the printk function\nCONFIG_ENTROPY_GENERATOR=y\nCONFIG_TEST_RANDOM_GENERATOR=y\n\n## LOGS\nCONFIG_LOG=y                    # Enable logger module\nCONFIG_LOG_BACKEND_SHOW_COLOR=n # Disable colors in the backend\nCONFIG_LOG_MODE_MINIMAL=y       # Enable minimal logging\n\n## CUSTOM\nCONFIG_MYFUNCTION=y # allows: #ifdef CONFIG_MYFUNCTION\n\n## THREADS\nCONFIG_TIMESLICING=y            ##enable timeslicing\nCONFIG_TIMESLICE_SIZE=10        # \u2191\nCONFIG_TIMESLICE_PRIORITY=0     # \u2191\n</code></pre>"},{"location":"briefcode/#overlay","title":"<code>.overlay</code>","text":"<p>In the <code>Details View</code>, there is an option to create an overlay file with the same board name used for the build. To apply changes do <code>pristine build</code>. In the same folder as prj.conf, eg: <code>nrf52833dk_nrf52833.overlay</code>.</p> <pre><code>&amp;uart0 {\n current-speed = &lt;9600&gt;;\n};\n</code></pre>"},{"location":"briefcode/#kconfigzephyr","title":"<code>Kconfig.zephyr</code>","text":"<p>Configuring system parameters</p> MYFUNCTION <pre><code>source \"Kconfig.zephyr\"\nconfig MYFUNCTION\n    bool \"Enable my function\"\n    default n\n</code></pre> <ul> <li> <p><code>source \"Kconfig.zephyr\"</code>: This line includes the contents of the file named \"Kconfig.zephyr\". This is typically used to include configuration options from another file.</p> </li> <li> <p><code>config MYFUNCTION</code>: This line declares a new configuration option named \"MYFUNCTION\".</p> </li> <li> <p><code>bool \"Enable my function\"</code>: This line sets the type of the configuration option to boolean, and provides a prompt string \"Enable my function\" that will be displayed to the user when they are configuring the system.</p> </li> <li> <p><code>default n</code>: This line sets the default value of the configuration option to 'n' (no). If the user does not explicitly set this option, it will be 'n'.</p> </li> </ul>"},{"location":"briefcode/#mainc","title":"<code>main.c</code>","text":"blinky - pooling data <pre><code>#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/device.h&gt;\n#include &lt;zephyr/devicetree.h&gt;\n#include &lt;zephyr/drivers/gpio.h&gt;\n\n/* STEP 7 - Change the sleep time from 1000 ms to 100 ms */\n#define SLEEP_TIME_MS   100\n\n/* STEP 3.1 - Get the node identifier for button 1 through its alias sw0 */\n#define SW0_NODE    DT_ALIAS(sw0)\n\n/* STEP 3.2 - Get the device pointer. pin number, and pin's configuration flags through gpio_dt_spec */\nstatic const struct gpio_dt_spec button = GPIO_DT_SPEC_GET(SW0_NODE, gpios);\n\n/* LED0_NODE is the devicetree node identifier for the \"led0\" alias. */\n#define LED0_NODE DT_ALIAS(led0)\nstatic const struct gpio_dt_spec led = GPIO_DT_SPEC_GET(LED0_NODE, gpios);\n\n\nvoid main(void)\n{\n    int ret;\n\n    if (!device_is_ready(led.port)) {\n        return;\n    }\n    /* STEP 4 - Verify that the device is ready for use */\n    if (!device_is_ready(button.port)) {\n        return;\n    }\n\n    ret = gpio_pin_configure_dt(&amp;led, GPIO_OUTPUT_ACTIVE);\n    if (ret &lt; 0) {\n        return;\n    }\n\n    /* STEP 5 - Configure the pin connected to the button to be an input pin and set its hardware specifications */\n    ret = gpio_pin_configure_dt(&amp;button, GPIO_INPUT);\n    if (ret &lt; 0) {\n        return;\n    }\n    while (1) {\n        /* STEP 6.1 - Read the status of the button and store it */\n        bool val = gpio_pin_get_dt(&amp;button);\n\n        /* STEP 6.2 - Update the LED to the status of the button */\n        gpio_pin_set_dt(&amp;led,val);\n\n        k_msleep(SLEEP_TIME_MS); // Put the main thread to sleep for 100ms for power optimization\n    }\n}\n</code></pre> blinky2 - button with callback <pre><code>#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/device.h&gt;\n#include &lt;zephyr/devicetree.h&gt;\n#include &lt;zephyr/drivers/gpio.h&gt;\n\n/* STEP 9 - Increase the sleep time from 100ms to 10 minutes  */\n#define SLEEP_TIME_MS   10*60*1000\n\n/* SW0_NODE is the devicetree node identifier for the node with alias \"sw0\" */\n#define SW0_NODE    DT_ALIAS(sw0) \nstatic const struct gpio_dt_spec button = GPIO_DT_SPEC_GET(SW0_NODE, gpios);\n\n/* LED0_NODE is the devicetree node identifier for the node with alias \"led0\". */\n#define LED0_NODE   DT_ALIAS(led0)\nstatic const struct gpio_dt_spec led = GPIO_DT_SPEC_GET(LED0_NODE, gpios);\n\n\n/* STEP 4 - Define the callback function */\nvoid button_pressed(const struct device *dev, struct gpio_callback *cb, uint32_t pins)\n{\n    gpio_pin_toggle_dt(&amp;led);\n}\n/* STEP 5 - Define a variable of type static struct gpio_callback */\nstatic struct gpio_callback button_cb_data;\n\nvoid main(void)\n{\n    int ret;\n\n    if (!device_is_ready(led.port)) {\n        return;\n    }\n\n    if (!device_is_ready(button.port)) {\n        return;\n    }\n\n    ret = gpio_pin_configure_dt(&amp;led, GPIO_OUTPUT_ACTIVE);\n    if (ret &lt; 0) {\n        return;\n    }\n\n    ret = gpio_pin_configure_dt(&amp;button, GPIO_INPUT);\n    if (ret &lt; 0) {\n        return;\n    }\n    /* STEP 3 - Configure the interrupt on the button's pin */\n    ret = gpio_pin_interrupt_configure_dt(&amp;button, GPIO_INT_EDGE_TO_ACTIVE );\n\n    /* STEP 6 - Initialize the static struct gpio_callback variable   */\n    gpio_init_callback(&amp;button_cb_data, button_pressed, BIT(button.pin));   \n\n    /* STEP 7 - Add the callback function by calling gpio_add_callback()   */\n     gpio_add_callback(button.port, &amp;button_cb_data);\n\n    while (1) {\n        /* STEP 8 - Remove the polling code */\n\n        k_msleep(SLEEP_TIME_MS);\n    }\n}\n</code></pre> myfun - enabled MYFUNCTION (need <code>Kconfig.zephyr</code> and <code>myfunction.h &amp; c</code>) <pre><code>#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/sys/printk.h&gt;\n\n#ifdef CONFIG_MYFUNCTION\n#include \"myfunction.h\"\n#endif\n\nvoid main(void)\n{\n\n    while(1){\n        #ifdef CONFIG_MYFUNCTION\n        int a = 3, b = 4;\n            printk(\"The sum of %d and %d is %d\\n\\r\", a, b, sum(a,b));\n        #else\n            printk(\"MYFUNCTION not enabled\\r\\n\");\n            return;\n        #endif\n        k_msleep(1000);\n    }\n}\n</code></pre> factorial - (ISR)Calculate and print factorials after button click <pre><code>#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/device.h&gt;\n#include &lt;zephyr/devicetree.h&gt;\n#include &lt;zephyr/drivers/gpio.h&gt;\n/* STEP 6 - Include the header file of printk */\n#include &lt;zephyr/sys/printk.h&gt;\n\n/* STEP 8.1 - Define the macro MAX_NUMBER_FACT that represents the maximum number to calculate its factorial  */\n#define MAX_NUMBER_FACT 10\n\n#define SLEEP_TIME_MS   10*60*1000\n\n#define SW0_NODE    DT_ALIAS(sw0)\nstatic const struct gpio_dt_spec button = GPIO_DT_SPEC_GET(SW0_NODE, gpios);\n\n#define LED0_NODE DT_ALIAS(led0)\nstatic const struct gpio_dt_spec led = GPIO_DT_SPEC_GET(LED0_NODE, gpios);\n\n/* STEP 8.2 - Replace the button callback function */\nvoid button_pressed(const struct device *dev, struct gpio_callback *cb,\n            uint32_t pins)\n{\n  int i;\n  int j;\n  long int factorial;\n  printk(\"Calculating the factorials of numbers from 1 to %d:\\n\\r\",MAX_NUMBER_FACT);\n  for (i=1;i&lt;=MAX_NUMBER_FACT;i++){\n       factorial =1;\n        for (j=1;j&lt;=i;j++){\n            factorial = factorial*j;\n        }\n        printk(\"The factorial of %2d = %ld\\n\\r\",i,factorial);\n  }\n  printk(\"_______________________________________________________\\n\\r\");\n  /*Important note! \n  Code in ISR runs at a high priority, therefore, it should be written with timing in mind.\n  Too lengthy or too complex tasks should not be performed by an ISR, they should be deferred to a thread. \n  */\n}\n\nstatic struct gpio_callback button_cb_data;\n\nvoid main(void)\n{\n    int ret;\n    /* STEP 7 - Print a simple banner */\n    printk(\"nRF Connect SDK Fundamentals - Lesson 4 - Exercise 1\\n\\r\");\n\n    /* Only checking one since led.port and button.port point to the same device, &amp;gpio0 */\n    if (!device_is_ready(led.port)) {\n        return;\n    }\n\n    ret = gpio_pin_configure_dt(&amp;led, GPIO_OUTPUT_ACTIVE);\n    if (ret &lt; 0) {\n        return;\n    }\n\n    ret = gpio_pin_configure_dt(&amp;button, GPIO_INPUT);\n    if (ret &lt; 0) {\n        return;\n    }\n\n    ret = gpio_pin_interrupt_configure_dt(&amp;button, GPIO_INT_EDGE_TO_ACTIVE);\n\n    gpio_init_callback(&amp;button_cb_data, button_pressed, BIT(button.pin));   \n\n    gpio_add_callback(button.port, &amp;button_cb_data);    \n    while (1) {\n        k_msleep(SLEEP_TIME_MS); \n    }\n}\n</code></pre> factorial_log - (ISR + Logger)Calculate and print factorials after button click <pre><code>#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/device.h&gt;\n#include &lt;zephyr/devicetree.h&gt;\n#include &lt;zephyr/drivers/gpio.h&gt;\n#include &lt;zephyr/sys/printk.h&gt;\n/* STEP 4 - Include the header file of the logger module */\n#include &lt;zephyr/logging/log.h&gt;\n\n#define MAX_NUMBER_FACT 10\n#define SLEEP_TIME_MS   10*60*1000\n\n#define SW0_NODE    DT_ALIAS(sw0)\nstatic const struct gpio_dt_spec button = GPIO_DT_SPEC_GET(SW0_NODE, gpios);\n\n#define LED0_NODE DT_ALIAS(led0)\nstatic const struct gpio_dt_spec led = GPIO_DT_SPEC_GET(LED0_NODE, gpios);\n\n/* STEP 5 - Register your code with the logger */\nLOG_MODULE_REGISTER(Less4_Exer2,LOG_LEVEL_DBG);\n\n/* STEP 7 - Replace the callback function button_pressed() */\nvoid button_pressed(const struct device *dev, struct gpio_callback *cb,\n            uint32_t pins)\n{\n  int i;\n  int j;\n  long int factorial;\n  LOG_INF(\"Calculating the factorials of numbers 1 to %d:\",MAX_NUMBER_FACT);\n  for (i=1;i&lt;=MAX_NUMBER_FACT;i++){\n       factorial =1;\n        for (j=1;j&lt;=i;j++){\n            factorial = factorial*j;\n        }\n        LOG_INF(\"The factorial of %2d = %ld\",i,factorial);\n  }\n  /*Important note! \n  Code in ISR runs at a high priority, therefore, it should be written with timing in mind.\n  Too lengthy or too complex tasks should not be performed by an ISR, they should be deferred to a thread \n  */\n}\n\nstatic struct gpio_callback button_cb_data;\n\nvoid main(void)\n{\n    int ret;\n    /* STEP 6 - Write some logs */\n    int exercise_num=2;\n    uint8_t data[] = {0x00, 0x01, 0x02, 0x03,\n                      0x04, 0x05, 0x06, 0x07,\n                      'H', 'e', 'l', 'l','o'};\n    //Printf-like messages\n    LOG_INF(\"nRF Connect SDK Fundamentals\");\n    LOG_INF(\"Exercise %d\",exercise_num);    \n    LOG_DBG(\"A log message in debug level\");\n    LOG_WRN(\"A log message in warning level!\");\n    LOG_ERR(\"A log message in Error level!\");\n    //Hexdump some data\n    LOG_HEXDUMP_INF(data, sizeof(data),\"Sample Data!\"); \n\n    /* Only checking one since led.port and button.port point to the same device, &amp;gpio0 */\n    if (!device_is_ready(led.port)) {\n        return;\n    }\n\n    ret = gpio_pin_configure_dt(&amp;led, GPIO_OUTPUT_ACTIVE);\n    if (ret &lt; 0) {\n        return;\n    }\n\n    ret = gpio_pin_configure_dt(&amp;button, GPIO_INPUT);\n    if (ret &lt; 0) {\n        return;\n    }\n\n        ret = gpio_pin_interrupt_configure_dt(&amp;button, GPIO_INT_EDGE_TO_ACTIVE);\n\n    gpio_init_callback(&amp;button_cb_data, button_pressed, BIT(button.pin));   \n\n    gpio_add_callback(button.port, &amp;button_cb_data);    \n    while (1) {\n        k_msleep(SLEEP_TIME_MS); \n    }\n}\n</code></pre> factorial_logh - (ISR + Logger) hexdump dbg data, Calculate and print factorials after button click <pre><code>#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/device.h&gt;\n#include &lt;zephyr/devicetree.h&gt;\n#include &lt;zephyr/drivers/gpio.h&gt;\n#include &lt;zephyr/sys/printk.h&gt;\n#include &lt;zephyr/logging/log.h&gt;\n\n#define MAX_NUMBER_FACT 10\n#define SLEEP_TIME_MS   10*60*1000\n\n#define SW0_NODE    DT_ALIAS(sw0)\nstatic const struct gpio_dt_spec button = GPIO_DT_SPEC_GET(SW0_NODE, gpios);\n\n#define LED0_NODE DT_ALIAS(led0)\nstatic const struct gpio_dt_spec led = GPIO_DT_SPEC_GET(LED0_NODE, gpios);\n\nLOG_MODULE_REGISTER(Less4_Exer3,LOG_LEVEL_DBG);\n\nvoid button_pressed(const struct device *dev, struct gpio_callback *cb,\n            uint32_t pins)\n{\n  int i;\n  int j;\n  long int factorial;\n  LOG_INF(\"Calculating the factorials of numbers 1 to %d:\",MAX_NUMBER_FACT);\n  for (i=1;i&lt;=MAX_NUMBER_FACT;i++){\n       factorial =1;\n        for (j=1;j&lt;=i;j++){\n            factorial = factorial*j;\n        }\n        LOG_INF(\"The factorial of %2d = %ld\",i,factorial);\n  }\n  /*Important note! \n  Code in ISR runs at a high priority, therefore, it should be written with timing in mind.\n  Too lengthy or too complex tasks should not be performed by an ISR, they should be deferred to a thread or a workqueue \n  */\n}\n\nstatic struct gpio_callback button_cb_data;\n\nvoid main(void)\n{\n    int ret;\n    int exercise_num = 3;\n    uint8_t data[] = {0x00, 0x01, 0x02, 0x03,\n                      0x04, 0x05, 0x06, 0x07,\n                      'H', 'e', 'l', 'l','o'};\n    //Printf-like messages\n    LOG_INF(\"nRF Connect SDK Fundamentals\");\n    LOG_INF(\"Exercise %d\",exercise_num);    \n    LOG_DBG(\"A log message in debug level\");\n    LOG_WRN(\"A log message in warning level!\");\n    LOG_ERR(\"A log message in error level!\");\n    //Hexdump some data\n    LOG_HEXDUMP_INF(data, sizeof(data),\"Sample Data!\"); \n\n    /* Only checking one since led.port and button.port point to the same device, &amp;gpio0 */\n    if (!device_is_ready(led.port)) {\n        return;\n    }\n\n    ret = gpio_pin_configure_dt(&amp;led, GPIO_OUTPUT_ACTIVE);\n    if (ret &lt; 0) {\n        return;\n    }\n\n    ret = gpio_pin_configure_dt(&amp;button, GPIO_INPUT);\n    if (ret &lt; 0) {\n    }\n\n    ret = gpio_pin_interrupt_configure_dt(&amp;button, GPIO_INT_EDGE_TO_ACTIVE);\n\n    gpio_init_callback(&amp;button_cb_data, button_pressed, BIT(button.pin));   \n\n    gpio_add_callback(button.port, &amp;button_cb_data);\n    while (1) {\n        k_msleep(SLEEP_TIME_MS); \n    }\n}\n</code></pre> key_ctrl - Controlling LEDs through UART. Press 1-3 on your keyboard (Enable the serial driver in asynchronous mode) <pre><code>#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/device.h&gt;\n#include &lt;zephyr/devicetree.h&gt;\n#include &lt;zephyr/drivers/gpio.h&gt;\n#include &lt;zephyr/sys/printk.h&gt;\n/* STEP 3 - Include the header file of the UART driver in main.c */\n#include &lt;zephyr/drivers/uart.h&gt;\n\n/* 1000 msec = 1 sec */\n#define SLEEP_TIME_MS   1000\n\n/* STEP 10.1.1 - Define the size of the receive buffer */\n#define RECEIVE_BUFF_SIZE 10\n\n/* STEP 10.2 - Define the receiving timeout period */\n#define RECEIVE_TIMEOUT 100\n\n/* STEP 5.1 - Get the device pointers of the LEDs through gpio_dt_spec */\n/* The nRF7002dk has only 2 LEDs so this step uses a compile-time condition to reflect the DK you are building for */\n#if defined (CONFIG_BOARD_NRF7002DK_NRF5340_CPUAPP)|| defined (CONFIG_BOARD_NRF7002DK_NRF5340_CPUAPP_NS)\nstatic const struct gpio_dt_spec led0 = GPIO_DT_SPEC_GET(DT_ALIAS(led0), gpios);\nstatic const struct gpio_dt_spec led1 = GPIO_DT_SPEC_GET(DT_ALIAS(led1), gpios);\n#else\nstatic const struct gpio_dt_spec led0 = GPIO_DT_SPEC_GET(DT_ALIAS(led0), gpios);\nstatic const struct gpio_dt_spec led1 = GPIO_DT_SPEC_GET(DT_ALIAS(led1), gpios);\nstatic const struct gpio_dt_spec led2 = GPIO_DT_SPEC_GET(DT_ALIAS(led2), gpios);\n#endif\n\n/* STEP 4.1 - Get the device pointer of the UART hardware */\nconst struct device *uart= DEVICE_DT_GET(DT_NODELABEL(uart0));\n\n\n/* STEP 9.1 - Define the transmission buffer, which is a buffer to hold the data to be sent over UART */\nstatic uint8_t tx_buf[] =   {\"nRF Connect SDK Fundamentals Course\\n\\r\"\n                             \"Press 1-3 on your keyboard to toggle LEDS 1-3 on your development kit\\n\\r\"};\n\n/* STEP 10.1.2 - Define the receive buffer */\nstatic uint8_t rx_buf[RECEIVE_BUFF_SIZE] = {0};\n\n/* STEP 7 - Define the callback function\u00a0for UART */\nstatic void uart_cb(const struct device *dev, struct uart_event *evt, void *user_data)\n{\n    switch (evt-&gt;type) {\n\n    case UART_RX_RDY:\n    #if defined (CONFIG_BOARD_NRF7002DK_NRF5340_CPUAPP)|| defined (CONFIG_BOARD_NRF7002DK_NRF5340_CPUAPP_NS)\n        if((evt-&gt;data.rx.len) == 1){\n\n        if(evt-&gt;data.rx.buf[evt-&gt;data.rx.offset] == '1')\n            gpio_pin_toggle_dt(&amp;led0);\n        else if (evt-&gt;data.rx.buf[evt-&gt;data.rx.offset] == '2')\n            gpio_pin_toggle_dt(&amp;led1);  \n        }\n    #else\n    if((evt-&gt;data.rx.len) == 1){\n\n        if(evt-&gt;data.rx.buf[evt-&gt;data.rx.offset] == '1')\n            gpio_pin_toggle_dt(&amp;led0);\n        else if (evt-&gt;data.rx.buf[evt-&gt;data.rx.offset] == '2')\n            gpio_pin_toggle_dt(&amp;led1);\n        else if (evt-&gt;data.rx.buf[evt-&gt;data.rx.offset] == '3')\n            gpio_pin_toggle_dt(&amp;led2);                  \n        }\n#endif\n    break;\n    case UART_RX_DISABLED:\n        uart_rx_enable(dev ,rx_buf,sizeof rx_buf,RECEIVE_TIMEOUT);\n        break;\n\n    default:\n        break;\n    }\n}\n\nint main(void)\n{\n    int ret;\n\n/* STEP 4.2 - Verify that the UART device is ready */ \n    if (!device_is_ready(uart)){\n        printk(\"UART device not ready\\r\\n\");\n        return 1 ;\n    }\n/* STEP 5.2 - Verify that the LED devices are ready */\n    if (!device_is_ready(led0.port)){\n        printk(\"GPIO device is not ready\\r\\n\");\n        return 1;\n    }\n/* STEP 6 - Configure the GPIOs of the LEDs */\n#if defined (CONFIG_BOARD_NRF7002DK_NRF5340_CPUAPP)|| defined (CONFIG_BOARD_NRF7002DK_NRF5340_CPUAPP_NS)\n    ret = gpio_pin_configure_dt(&amp;led0, GPIO_OUTPUT_ACTIVE);\n    if (ret &lt; 0) {\n        return 1 ; \n    }\n    ret = gpio_pin_configure_dt(&amp;led1, GPIO_OUTPUT_ACTIVE);\n    if (ret &lt; 0) {\n        return 1 ;\n    }\n#else\nret = gpio_pin_configure_dt(&amp;led0, GPIO_OUTPUT_ACTIVE);\n    if (ret &lt; 0) {\n        return 1 ; \n    }\n    ret = gpio_pin_configure_dt(&amp;led1, GPIO_OUTPUT_ACTIVE);\n    if (ret &lt; 0) {\n        return 1 ;\n    }\n    ret = gpio_pin_configure_dt(&amp;led2, GPIO_OUTPUT_ACTIVE);\n    if (ret &lt; 0) {\n        return 1 ;\n    }\n#endif\n\n/* STEP 8 - Register the UART callback function */\n    ret = uart_callback_set(uart, uart_cb, NULL);\n        if (ret) {\n            return 1;\n        }\n/* STEP 9.2 - Send the data over UART by calling uart_tx() */\n    ret = uart_tx(uart, tx_buf, sizeof(tx_buf), SYS_FOREVER_MS);\n    if (ret) {\n        return 1;\n    }\n/* STEP 10.3  - Start receiving by calling uart_rx_enable() and pass it the address of the receive  buffer */\n    ret = uart_rx_enable(uart ,rx_buf,sizeof rx_buf,RECEIVE_TIMEOUT);\n    if (ret) {\n        return 1;\n    }\n    while (1) {\n        k_msleep(SLEEP_TIME_MS);\n    }\n\n}\n</code></pre> sen_i2c - get data from i2c temp sensor SSTS751 (Enable CONFIG_I2C &amp; CONFIG_CBPRINTF_FP_SUPPORT) <pre><code>#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/device.h&gt;\n#include &lt;zephyr/devicetree.h&gt;\n/* STEP 3 - Include the header file of the I2C API */\n#include &lt;zephyr/drivers/i2c.h&gt;\n/* STEP 4.1 - Include the header file of printk() */\n#include &lt;zephyr/sys/printk.h&gt;\n/* 1000 msec = 1 sec */\n#define SLEEP_TIME_MS   1000\n\n/* STEP 8 - Define the I2C slave device address and the addresses of relevant registers */\n#define STTS751_TEMP_HIGH_REG            0x00\n#define STTS751_TEMP_LOW_REG             0x02\n#define STTS751_CONFIG_REG               0x03\n\n/* STEP 6 - Get the node identifier of the sensor */\n#define I2C_NODE DT_NODELABEL(mysensor)\n\nvoid main(void)\n{\n\n    int ret;\n\n/* STEP 7 - Retrieve the API-specific device structure and make sure that the device is ready to use  */\n    static const struct i2c_dt_spec dev_i2c = I2C_DT_SPEC_GET(I2C_NODE);\n    if (!device_is_ready(dev_i2c.bus)) {\n        printk(\"I2C bus %s is not ready!\\n\\r\",dev_i2c.bus-&gt;name);\n        return;\n    }\n\n/* STEP 9 - Setup the sensor by writing the value 0x8C to the Configuration register */\n    uint8_t config[2] = {STTS751_CONFIG_REG,0x8C};\n    ret = i2c_write_dt(&amp;dev_i2c, config, sizeof(config));\n    if(ret != 0){\n        printk(\"Failed to write to I2C device address %x at Reg. %x \\n\", dev_i2c.addr,config[0]);\n        return;\n    }\n\n    while (1) {\n/* STEP 10 - Read the temperature from the sensor */\n        uint8_t temp_reading[2]= {0};\n        uint8_t sensor_regs[2] ={STTS751_TEMP_LOW_REG,STTS751_TEMP_HIGH_REG};\n        ret = i2c_write_read_dt(&amp;dev_i2c,&amp;sensor_regs[0],1,&amp;temp_reading[0],1);\n        if(ret != 0){\n            printk(\"Failed to write/read I2C device address %x at Reg. %x \\r\\n\", dev_i2c.addr,sensor_regs[0]);\n        }\n        ret = i2c_write_read_dt(&amp;dev_i2c,&amp;sensor_regs[1],1,&amp;temp_reading[1],1);\n        if(ret != 0){\n            printk(\"Failed to write/read I2C device address %x at Reg. %x \\r\\n\", dev_i2c.addr,sensor_regs[1]);\n        }\n\n/* STEP 11 - Convert the two bytes to a 12-bits */\n        int temp = ((int)temp_reading[1] * 256 + ((int)temp_reading[0] &amp; 0xF0)) / 16;\n        if(temp &gt; 2047)\n        {\n            temp -= 4096;\n        }\n\n        // Convert to engineering units \n        double cTemp = temp * 0.0625;\n        double fTemp = cTemp * 1.8 + 32;\n\n        //Print reading to console  \n        printk(\"Temperature in Celsius : %.2f C \\n\", cTemp);\n        printk(\"Temperature in Fahrenheit : %.2f F \\n\", fTemp);\n        k_msleep(SLEEP_TIME_MS);\n    }\n}\n</code></pre> sen2_i2c - get data from i2c RGB sensor BH1749 (Enable CONFIG_I2C &amp; CONFIG_CBPRINTF_FP_SUPPORT) <pre><code>#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/device.h&gt;\n#include &lt;zephyr/devicetree.h&gt;\n/* STEP 3 - Include the header file of the I2C API */\n#include &lt;zephyr/drivers/i2c.h&gt;\n/* STEP 4.1 - Include the header file of printk() */\n#include &lt;zephyr/sys/printk.h&gt;\n/* 1000 msec = 1 sec */\n#define SLEEP_TIME_MS   1000\n\n/* STEP 8 - Define the the addresses of relevant sensor registers and settings */\n#define BH1749_SYSTEM_CONTROL                           0x40\n#define BH1749_MODE_CONTROL1                            0x41\n#define BH1749_MODE_CONTROL2                            0x42\n#define BH1749_RED_DATA_LSB                             0x50\n#define BH1749_MODE_CONTROL2_RGB_EN_ENABLE              BIT(4)\n/* IR Gain: 1x, RGB Gain: 1x, Measurement mode: 120ms mode */\n#define BH1749_MODE_CONTROL1_DEFAULTS                   0x2A\n\n/* STEP 6 - Get the node identifier of the sensor */\n#define I2C_NODE DT_NODELABEL(bh1749)\n\nvoid main(void)\n{\n\n    int ret;\n\n/* STEP 7 - Retrieve the API-specific device structure and make sure that the device is ready to use  */\n    static const struct i2c_dt_spec dev_i2c = I2C_DT_SPEC_GET(I2C_NODE);\n    if (!device_is_ready(dev_i2c.bus)) {\n        printk(\"I2C bus %s is not ready!\\n\\r\",dev_i2c.bus-&gt;name);\n        return;\n    }\n\n/* STEP 9 - Setup the sensor by writing the value 0x2A to the MODE_CONTROL1 register \n0x2A Means : IR Gain: 1x, RGB Gain: 1x, Measurement mode: 120ms mode\n*/\n    char buff1[] = {BH1749_MODE_CONTROL1,BH1749_MODE_CONTROL1_DEFAULTS};\n    ret = i2c_write_dt(&amp;dev_i2c,buff1,sizeof(buff1));\n    if(ret != 0){\n            printk(\"Failed to write to I2C device address 0x%c at Reg. 0x%c\\n\",dev_i2c.addr,BH1749_MODE_CONTROL1);\n        }\n/* STEP 10 - Enable measurement by writing 1 to bit 4 of the MODE_CONTROL2 register */\n    char buff2[] = {BH1749_MODE_CONTROL2,BH1749_MODE_CONTROL2_RGB_EN_ENABLE};\n    ret = i2c_write_dt(&amp;dev_i2c,buff2,sizeof(buff2));\n    if(ret != 0){\n        printk(\"Failed to write to I2C device address 0x%c at Reg. 0x%c\\n\",dev_i2c.addr,BH1749_MODE_CONTROL2);\n    }\n\n    while (1) {\n/* STEP 11 - Read the RGB values from the sensor */\n        uint8_t rgb_value[6]= {0};//3 colour channels x 2 = 6\n        //Do a burst read of 6 bytes as each color channel is 2 bytes. \n        ret = i2c_burst_read_dt(&amp;dev_i2c, BH1749_RED_DATA_LSB,rgb_value,sizeof(rgb_value));\n        if(ret != 0){\n            printk(\"Failed to read to I2C device address 0x%c at Reg. 0x%c\\n\",dev_i2c.addr,BH1749_RED_DATA_LSB);\n        }\n        //Print reading to console  \n        printk(\"_______________________________\\n\");\n        printk(\"Red Value:\\t %d\\n\", (rgb_value[0] | rgb_value[1] &lt;&lt; 8));\n        printk(\"Green Value:\\t %d\\n\", (rgb_value[2] | rgb_value[3] &lt;&lt; 8));\n        printk(\"Blue Value:\\t %d\\n\", (rgb_value[4] | rgb_value[5] &lt;&lt; 8));\n\n        k_msleep(SLEEP_TIME_MS);\n    }\n}\n</code></pre> thrd - threads creation (Enable CONFIG_PRINTK) <pre><code>#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/sys/printk.h&gt;\n\n/* STEP 2 - Define stack size and scheduling priority used by each thread */\n#define STACKSIZE 1024\n\n#define THREAD0_PRIORITY 7\n#define THREAD1_PRIORITY 7\n\nvoid thread0(void)\n{\n    while (1) {\n          /* STEP 3 - Call printk() to display a simple string \"Hello, I am thread0\" */\n          printk(\"Hello, I am thread0\\n\");\n          /* STEP 6 - Make the thread yield */\n          //k_yield();\n          /* STEP 10 - Put the thread to sleep */\n          k_msleep(5);\n          /* Remember to comment out the line from STEP 6 */\n    }\n}\n\nvoid thread1(void)\n{\n    while (1) {\n          /* STEP 3 - Call printk() to display a simple string \"Hello, I am thread1\" */\n          printk(\"Hello, I am thread1\\n\");        \n          /* STEP 8 - Make the thread yield */\n          //k_yield();        \n          /* STEP 10 - Put the thread to sleep */\n          k_msleep(5);\n          /* Remember to comment out the line from STEP 8 */\n    }\n}\n\n/* STEP 4 - Define and initialize the two threads */\nK_THREAD_DEFINE(thread0_id, STACKSIZE, thread0, NULL, NULL, NULL,\n        THREAD0_PRIORITY, 0, 0);\nK_THREAD_DEFINE(thread1_id, STACKSIZE, thread1, NULL, NULL, NULL,\n        THREAD1_PRIORITY, 0, 0);\n</code></pre> thrd_ts - threads creation with timeslicing (Enable CONFIG_PRINTK, timeslicing) <pre><code>#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/sys/printk.h&gt;\n\n#define STACKSIZE 1024\n\n/* STEP 5 - Change the priority of thread0 to 6 */\n#define THREAD0_PRIORITY 6\n#define THREAD1_PRIORITY 7\n\nvoid thread0(void)\n{\n    while (1) {\n          printk(\"Hello, I am thread0\\n\");\n          k_busy_wait(1000000);\n    }\n}\n\nvoid thread1(void)\n{\n    while (1) {\n          printk(\"Hello, I am thread1\\n\");\n          k_busy_wait(1000000);\n    }\n}\n\nK_THREAD_DEFINE(thread0_id, STACKSIZE, thread0, NULL, NULL, NULL,\n        THREAD0_PRIORITY, 0, 0);\nK_THREAD_DEFINE(thread1_id, STACKSIZE, thread1, NULL, NULL, NULL,\n        THREAD1_PRIORITY, 0, 0);\n</code></pre> thrd_wq - workqueue threads creation (Enable CONFIG_PRINTK) <pre><code>/*\n * Copyright (c) 2017 Linaro Limited\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/sys/printk.h&gt;\n#include &lt;string.h&gt;\n// Define stack size used by each thread\n#define THREAD0_STACKSIZE       512\n#define THREAD1_STACKSIZE       512\n#define WORQ_THREAD_STACK_SIZE  512\n\n/* STEP 2 - Set the priorities of the threads */\n#define THREAD0_PRIORITY 2 \n#define THREAD1_PRIORITY 3\n#define WORKQ_PRIORITY   4\n\n// Define stack area used by workqueue thread\nstatic K_THREAD_STACK_DEFINE(my_stack_area, WORQ_THREAD_STACK_SIZE);\n\n// Define queue structure\nstatic struct k_work_q offload_work_q = {0};\n\n\n/* STEP 5 - Define function to emulate non-urgent work */\nstatic inline void emulate_work()\n{\n    for(volatile int count_out = 0; count_out &lt; 150000; count_out ++);\n}\n\n/* STEP 7 - Create work_info structure and offload function */\nstruct work_info {\n    struct k_work work;\n    char name[25];\n} my_work;\n\nvoid offload_function(struct k_work *work_tem)\n{\n    emulate_work();\n}\n\nvoid thread0(void)\n{\n    uint64_t time_stamp;\n    int64_t delta_time;\n    /* STEP 8 - Start the workqueue, */\n    /* initialize the work item and connect it to its handler function */ \n    k_work_queue_start(&amp;offload_work_q, my_stack_area,\n                    K_THREAD_STACK_SIZEOF(my_stack_area), WORKQ_PRIORITY,\n                    NULL);\n    strcpy(my_work.name, \"Thread0 emulate_work()\");\n    k_work_init(&amp;my_work.work, offload_function);\n    while (1) {\n        time_stamp = k_uptime_get();\n        /* STEP 9 - Submit the work item to the workqueue instead of calling emulate_work() directly */\n        /* Remember to comment out emulate_work(); */\n        k_work_submit_to_queue(&amp;offload_work_q, &amp;my_work.work);\n        delta_time = k_uptime_delta(&amp;time_stamp);\n        printk(\"thread0 yielding this round in %lld ms\\n\", delta_time);\n        k_msleep(20);\n    }   \n}\n\n/* STEP 4 - Define entry function for thread1 */\nvoid thread1(void)\n{\n    uint64_t time_stamp;\n    int64_t delta_time;\n\n    while (1) {\n        time_stamp = k_uptime_get();\n        emulate_work();\n        delta_time = k_uptime_delta(&amp;time_stamp);\n\n        printk(\"thread1 yielding this round in %lld ms\\n\", delta_time);\n        k_msleep(20);\n    }   \n}\n\nK_THREAD_DEFINE(thread0_id, THREAD0_STACKSIZE, thread0, NULL, NULL, NULL,\n        THREAD0_PRIORITY, 0, 0);\nK_THREAD_DEFINE(thread1_id, THREAD1_STACKSIZE, thread1, NULL, NULL, NULL,\n        THREAD1_PRIORITY, 0, 0);\n</code></pre> thrd_semaphore - producer &amp; consumer problem with <code>semaphore</code> (Enable CONFIG_PRINTK, CONFIG_ENTROPY_GENERATOR, CONFIG_TEST_RANDOM_GENERATOR) <pre><code>#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/sys/printk.h&gt;\n#include &lt;zephyr/random/rand32.h&gt;\n\n#define PRODUCER_STACKSIZE       512\n#define CONSUMER_STACKSIZE       512\n\n/* STEP 2 - Set the priority of the producer and consumper thread */\n#define PRODUCER_PRIORITY 5 \n#define CONSUMER_PRIORITY 4\n\n/* STEP 9 - Define semaphore to monitor instances of available resource */\nK_SEM_DEFINE(instance_monitor_sem, 10, 10);\n\n/* STEP 3 - Initialize the available instances of this resource */\nvolatile uint32_t available_instance_count = 10;\n\n// Function for getting access of resource\nvoid get_access(void)\n{\n    /* STEP 10.1 - Get semaphore before access to the resource */\n    k_sem_take(&amp;instance_monitor_sem, K_FOREVER);\n\n    /* STEP 6.1 - Decrement available resource */\n    available_instance_count--;\n    printk(\"Resource taken and available_instance_count = %d\\n\", available_instance_count);\n}\n\n// Function for releasing access of resource\nvoid release_access(void)\n{\n    /* STEP 6.2 - Increment available resource */\n    available_instance_count++;\n    printk(\"Resource given and available_instance_count = %d\\n\", available_instance_count);\n\n    /* STEP 10.2 - Give semaphore after finishing access to resource */\n    k_sem_give(&amp;instance_monitor_sem);\n}\n\n/* STEP 4 - Producer thread relinquishing access to instance */\nvoid producer(void)\n{\n    printk(\"Producer thread started\\n\");\n    while (1) {\n        release_access();\n        // Assume the resource instance access is released at this point\n        k_msleep(500 + sys_rand32_get() % 10);\n    }\n}\n\n/* STEP 5 - Consumer thread obtaining access to instance */\nvoid consumer(void)\n{\n    printk(\"Consumer thread started\\n\");\n    while (1) {\n        get_access();\n        // Assume the resource instance access is released at this point\n        k_msleep( sys_rand32_get() % 10);\n    }\n}\n\nK_THREAD_DEFINE(producer_id, PRODUCER_STACKSIZE, producer, NULL, NULL, NULL,\n        PRODUCER_PRIORITY, 0, 0);\n\nK_THREAD_DEFINE(consumer_id, CONSUMER_STACKSIZE, consumer, NULL, NULL, NULL,\n        CONSUMER_PRIORITY, 0, 0);\n</code></pre> thrd_mutex - race condition problem with <code>mutex</code> (Enable CONFIG_PRINTK, CONFIG_ENTROPY_GENERATOR, CONFIG_TEST_RANDOM_GENERATOR, timeslicing) <pre><code>#include &lt;zephyr/kernel.h&gt;\n#include &lt;zephyr/sys/printk.h&gt;\n#include &lt;zephyr/random/rand32.h&gt;\n#include &lt;string.h&gt;\n\n#define THREAD0_STACKSIZE       512\n#define THREAD1_STACKSIZE       512\n\n/* STEP 3 - Set the priority of the two threads to have equal priority*/\n#define THREAD0_PRIORITY 4 \n#define THREAD1_PRIORITY 4\n\n/* STEP 5 - Define the two counters with a constant combined total */\n#define COMBINED_TOTAL   40\n\nint32_t increment_count = 0; \nint32_t decrement_count = COMBINED_TOTAL; \n\n/* STEP 11 - Define mutex to protect access to shared code section */\nK_MUTEX_DEFINE(test_mutex);\n\n// Shared code run by both threads\nvoid shared_code_section(void)\n{\n    /* STEP 12.1 - Lock the mutex */\n    k_mutex_lock(&amp;test_mutex, K_FOREVER);\n\n    /* STEP 6 - Increment count and decrement count changed */\n    /* according to logic defined in exercise text */\n    increment_count += 1;\n    increment_count = increment_count % COMBINED_TOTAL; \n\n    decrement_count -= 1;\n    if (decrement_count == 0) \n    {\n        decrement_count = COMBINED_TOTAL;\n    }\n\n    /* STEP 12.2 - Unlock the mutex */\n    k_mutex_unlock(&amp;test_mutex);\n\n    /* STEP 7 - Print counter values if they do not add up to COMBINED_TOTAL */\n    if(increment_count + decrement_count != COMBINED_TOTAL )\n    {\n        printk(\"Race condition happend!\\n\");\n        printk(\"Increment_count (%d) + Decrement_count (%d) = %d \\n\",\n                    increment_count, decrement_count, (increment_count + decrement_count));\n        k_msleep(400 + sys_rand32_get() % 10);\n    }\n}\n\n/* STEP 4 - Functions for thread0 and thread1 with a shared code section */\nvoid thread0(void)\n{\n    printk(\"Thread 0 started\\n\");\n    while (1) {\n        shared_code_section(); \n    }\n}\n\nvoid thread1(void)\n{\n    printk(\"Thread 1 started\\n\");\n    while (1) {\n        shared_code_section(); \n    }\n}\n\n// Define and initialize threads\nK_THREAD_DEFINE(thread0_id, THREAD0_STACKSIZE, thread0, NULL, NULL, NULL,\n        THREAD0_PRIORITY, 0, 5000);\n\nK_THREAD_DEFINE(thread1_id, THREAD1_STACKSIZE, thread1, NULL, NULL, NULL,\n        THREAD1_PRIORITY, 0, 5000);\n</code></pre>"}]}